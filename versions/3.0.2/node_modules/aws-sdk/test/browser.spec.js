(function() {
  var AWS, config, dynamodb, eventually, helpers, integration, integrationTests, noError, s3, sns, sqs, sts, uniqueName;

  helpers = require('./helpers');

  AWS = helpers.AWS;

  config = {};

  try {
    config = require('./configuration');
  } catch (error) {}

  s3 = new AWS.S3(AWS.util.merge(config, config.s3));

  dynamodb = new AWS.DynamoDB(AWS.util.merge(config, config.dynamodb));

  sqs = new AWS.SQS(AWS.util.merge(config, config.sqs));

  sns = new AWS.SNS(AWS.util.merge(config, config.sns));

  sts = new AWS.STS(AWS.util.merge(config, config.sts));

  uniqueName = function(prefix) {
    if (prefix) {
      return prefix + '-' + AWS.util.date.getDate().getTime();
    } else {
      return AWS.util.date.getDate().getTime().toString();
    }
  };

  eventually = function(condition, next, done) {
    var delay, id, nextFn, options, started;
    options = {
      delay: 0,
      backoff: 500,
      maxTime: 10
    };
    delay = options.delay;
    started = AWS.util.date.getDate();
    id = 0;
    nextFn = function() {
      var now;
      now = AWS.util.date.getDate();
      if (now - started < options.maxTime * 1000) {
        return next(function(err, data) {
          var timeoutFn;
          if (condition(err, data)) {
            return done(err, data);
          } else {
            timeoutFn = function() {
              clearInterval(id);
              delay += options.backoff;
              return nextFn();
            };
            return id = setInterval(timeoutFn, delay);
          }
        });
      }
    };
    return nextFn();
  };

  noError = function(err) {
    return expect(err).toEqual(null);
  };

  integration = function(label, fn) {
    if (label.match(/\(no phantomjs\)/) && navigator.userAgent.match(/phantomjs/i)) {
      return;
    }
    return it(label, function() {
      var done;
      done = false;
      runs(function() {
        return fn(function() {
          return done = true;
        });
      });
      return waitsFor(function() {
        return done === true;
      });
    });
  };

  integrationTests = function(fn) {
    if (config.accessKeyId && AWS.util.isBrowser()) {
      return describe('Integration tests', fn);
    }
  };

  integrationTests(function() {
    describe('Request.abort', function() {
      return it('can abort a request', function() {
        var done, err;
        err = null;
        done = null;
        runs(function() {
          var req;
          req = s3.putObject({
            Key: 'key',
            Body: 'body'
          });
          req.on('complete', function(resp) {
            done = true;
            return err = resp.error;
          });
          req.on('send', function(resp) {
            return resp.request.abort();
          });
          return req.send();
        });
        waitsFor(function() {
          return done;
        });
        return runs(function() {
          return expect(err.name).toEqual('RequestAbortedError');
        });
      });
    });
    describe('XHR', function() {
      it('does not emit http events if networking issue occurs', function() {
        var done, err, httpData, httpDone, httpError, httpHeaders;
        err = null;
        done = null;
        httpHeaders = false;
        httpData = false;
        httpError = false;
        httpDone = false;
        runs(function() {
          var date, req, svc;
          svc = new AWS.S3({
            accessKeyId: 'akid',
            secretAccessKey: 'secret',
            maxRetries: 0
          });
          date = AWS.util.date.iso8601().replace(/[^0-9]/g, '');
          req = svc.getObject({
            Bucket: 'invalidbucket' + date,
            Key: 'foo'
          });
          req.on('httpHeaders', function() {
            return httpHeaders = true;
          });
          req.on('httpData', function() {
            return httpData = true;
          });
          req.on('httpDone', function() {
            return httpDone = true;
          });
          req.on('httpError', function() {
            return httpError = true;
          });
          req.on('complete', function(resp) {
            done = true;
            return err = resp.error;
          });
          return req.send();
        });
        waitsFor(function() {
          return done;
        });
        return runs(function() {
          expect(httpHeaders).toEqual(false);
          expect(httpData).toEqual(false);
          expect(httpDone).toEqual(false);
          expect(httpError).toEqual(true);
          return expect(err.name).toEqual('NetworkingError');
        });
      });
      return integration('can send synchronous requests (no phantomjs)', function(done) {
        var key, opts, resp1, resp2, svc;
        key = uniqueName('test');
        opts = AWS.util.merge(config, config.s3);
        opts.httpOptions = {
          xhrAsync: false
        };
        svc = new AWS.S3(opts);
        resp1 = svc.putObject({
          Key: key,
          Body: 'body'
        }).send();
        resp2 = svc.getObject({
          Key: key
        }).send();
        expect(resp2.data.Body.toString()).toEqual('body');
        svc.deleteObject({
          Key: key
        }).send();
        return done();
      });
    });
    describe('AWS.S3', function() {
      var testWrite;
      testWrite = function(done, body, compareFn) {
        var key;
        key = uniqueName('test');
        return s3.putObject({
          Key: key,
          Body: body
        }, function(err, data) {
          noError(err);
          return s3.getObject({
            Key: key
          }, function(err, data) {
            noError(err);
            if (compareFn) {
              compareFn(data);
            } else {
              expect(data.Body.toString()).toEqual(body);
            }
            return s3.deleteObject({
              Key: key
            }).send(done);
          });
        });
      };
      integration('GETs and PUTs objects to a bucket (no phantomjs)', function(done) {
        return testWrite(done, 'ƒoo');
      });
      integration('writes typed array data (no phantomjs)', function(done) {
        return testWrite(done, new Uint8Array([2, 4, 8]), function(data) {
          expect(data.Body[0]).toEqual(2);
          expect(data.Body[1]).toEqual(4);
          return expect(data.Body[2]).toEqual(8);
        });
      });
      integration('writes blobs (no phantomjs)', function(done) {
        return testWrite(done, new Blob(['a', 'b', 'c']), function(data) {
          expect(data.Body[0]).toEqual(97);
          expect(data.Body[1]).toEqual(98);
          return expect(data.Body[2]).toEqual(99);
        });
      });
      integration('writes with charset', function(done) {
        var body, key;
        key = uniqueName('test');
        body = 'body string';
        s3.putObject({
          Key: key,
          Body: body,
          ContentType: 'text/html'
        }, function(err, data) {
          noError(err);
          return s3.deleteObject({
            Key: key
          }).send(done);
        });
        return s3.putObject({
          Key: key,
          Body: body,
          ContentType: 'text/html; charset=utf-8'
        }, function(err, data) {
          noError(err);
          return s3.deleteObject({
            Key: key
          }).send(done);
        });
      });
      return describe('progress events', function() {
        return integration('emits http(Upload|Download)Progress events (no phantomjs)', function(done) {
          var body, data, key, progress, req;
          data = [];
          progress = [];
          key = uniqueName('test');
          body = new Blob([new Array(512 * 1024).join('x')]);
          req = s3.putObject({
            Key: key,
            Body: body
          });
          req.on('httpUploadProgress', function(p) {
            return progress.push(p);
          });
          return req.send(function(err, data) {
            noError(err);
            expect(progress.length > 1).toEqual(true);
            expect(progress[0].total).toEqual(body.size);
            expect(progress[0].loaded > 10).toEqual(true);
            progress = [];
            req = s3.getObject({
              Key: key
            });
            req.on('httpDownloadProgress', function(p) {
              return progress.push(p);
            });
            return req.send(function(err, data) {
              noError(err);
              expect(progress.length > 1).toEqual(true);
              expect(progress[0].total).toEqual(body.size);
              expect(progress[0].loaded > 10).toEqual(true);
              s3.deleteObject({
                Key: key
              }).send();
              return done();
            });
          });
        });
      });
    });
    describe('AWS.DynamoDB', function() {
      return integration('writes and reads from a table', function(done) {
        var key;
        key = uniqueName('test');
        return dynamodb.putItem({
          Item: {
            id: {
              S: key
            },
            data: {
              S: 'ƒoo'
            }
          }
        }, function(err, data) {
          noError(err);
          return dynamodb.getItem({
            Key: {
              id: {
                S: key
              }
            }
          }, function(err, data) {
            noError(err);
            expect(data.Item.data.S).toEqual('ƒoo');
            return dynamodb.deleteItem({
              Key: {
                id: {
                  S: key
                }
              }
            }).send(done);
          });
        });
      });
    });
    describe('AWS.STS', function() {
      return integration('gets a session token', function(done) {
        return sts.getSessionToken(function(err, data) {
          noError(err);
          expect(data.Credentials.AccessKeyId).not.toEqual('');
          return done();
        });
      });
    });
    describe('AWS.SQS', function() {
      return integration('posts and receives messages on a queue', function(done) {
        var msg, name;
        name = uniqueName('aws-sdk-js');
        msg = 'ƒoo';
        return sqs.createQueue({
          QueueName: name
        }, function(err, data) {
          var url;
          url = data.QueueUrl;
          sqs = new AWS.SQS(sqs.config);
          sqs.config.params = {
            QueueUrl: url
          };
          return eventually((function(err) {
            return err === null;
          }), (function(cb) {
            return sqs.getQueueUrl({
              QueueName: name
            }, cb);
          }), function() {
            return sqs.sendMessage({
              MessageBody: msg
            }, function(err, data) {
              noError(err);
              return eventually((function(err, data) {
                return data.Messages[0].Body === msg;
              }), (function(cb) {
                return sqs.receiveMessage(cb);
              }), function(err, data) {
                noError(err);
                expect(data.Messages[0].MD5OfBody).toEqual(AWS.util.crypto.md5(msg, 'hex'));
                return sqs.deleteQueue(done);
              });
            });
          });
        });
      });
    });
    return describe('AWS.SNS', function() {
      return integration('creates and deletes topics', function(done) {
        return sns.createTopic({
          Name: uniqueName('aws-sdk-js')
        }, function(err, data) {
          var arn;
          noError(err);
          arn = data.TopicArn;
          sns = new AWS.SNS(sns.config);
          sns.config.params = {
            TopicArn: arn
          };
          return sns.listTopics(function(err, data) {
            expect(data.Topics.filter(function(o) {
              return o.TopicArn === arn;
            })).not.toEqual(null);
            return sns.deleteTopic(done);
          });
        });
      });
    });
  });

}).call(this);
