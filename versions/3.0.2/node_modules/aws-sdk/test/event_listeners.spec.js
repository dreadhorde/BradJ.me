(function() {
  var AWS, MockService, helpers;

  helpers = require('./helpers');

  AWS = helpers.AWS;

  MockService = helpers.MockService;

  describe('AWS.EventListeners', function() {
    var completeHandler, config, delays, errorHandler, makeRequest, oldSetTimeout, retryHandler, service, successHandler, totalWaited;
    oldSetTimeout = setTimeout;
    config = null;
    service = null;
    totalWaited = null;
    delays = [];
    successHandler = null;
    errorHandler = null;
    completeHandler = null;
    retryHandler = null;
    beforeEach(function() {
      setTimeout = jasmine.createSpy('setTimeout');;
      setTimeout.andCallFake(function(callback, delay) {
        totalWaited += delay;
        delays.push(delay);
        return callback();
      });
      totalWaited = 0;
      delays = [];
      service = new MockService({
        maxRetries: 3
      });
      service.config.credentials = AWS.util.copy(service.config.credentials);
      successHandler = jasmine.createSpy('success');
      errorHandler = jasmine.createSpy('error');
      completeHandler = jasmine.createSpy('complete');
      return retryHandler = jasmine.createSpy('retry');
    });
    afterEach(function() {
      return setTimeout = oldSetTimeout;
    });
    makeRequest = function(callback) {
      var request;
      request = service.makeRequest('mockMethod', {
        foo: 'bar'
      });
      request.on('retry', retryHandler);
      request.on('error', errorHandler);
      request.on('success', successHandler);
      request.on('complete', completeHandler);
      if (callback) {
        return request.send(callback);
      } else {
        return request;
      }
    };
    describe('validate', function() {
      it('takes the request object as a parameter', function() {
        var request, response;
        request = makeRequest();
        request.on('validate', function(req) {
          expect(req).toBe(request);
          throw "ERROR";
        });
        response = request.send(function() {});
        return expect(response.error).toEqual("ERROR");
      });
      it('sends error event if credentials are not set', function() {
        service.config.credentialProvider = null;
        service.config.credentials.accessKeyId = null;
        makeRequest(function() {});
        expect(errorHandler).toHaveBeenCalled();
        return AWS.util.arrayEach(errorHandler.calls, function(call) {
          expect(call.args[0] instanceof Error).toBeTruthy();
          expect(call.args[0].code).toEqual('CredentialsError');
          return expect(call.args[0].message).toMatch(/Missing credentials/);
        });
      });
      it('sends error event if credentials are not set', function() {
        service.config.credentials.accessKeyId = 'akid';
        service.config.credentials.secretAccessKey = null;
        makeRequest(function() {});
        expect(errorHandler).toHaveBeenCalled();
        return AWS.util.arrayEach(errorHandler.calls, function(call) {
          expect(call.args[0] instanceof Error).toBeTruthy();
          expect(call.args[0].code).toEqual('CredentialsError');
          return expect(call.args[0].message).toMatch(/Missing credentials/);
        });
      });
      it('does not validate credentials if request is not signed', function() {
        var request;
        helpers.mockHttpResponse(200, {}, '');
        service.api = new AWS.Model.Api({
          metadata: {
            endpointPrefix: 'mockservice',
            signatureVersion: null
          }
        });
        request = makeRequest();
        request.send(function() {});
        expect(errorHandler).not.toHaveBeenCalled();
        return expect(successHandler).toHaveBeenCalled();
      });
      it('sends error event if region is not set', function() {
        var call, request;
        service.config.region = null;
        request = makeRequest(function() {});
        call = errorHandler.calls[0];
        expect(errorHandler).toHaveBeenCalled();
        expect(call.args[0] instanceof Error).toBeTruthy();
        expect(call.args[0].code).toEqual('SigningError');
        return expect(call.args[0].message).toMatch(/Missing region in config/);
      });
      return it('ignores region validation if service has global endpoint', function() {
        helpers.mockHttpResponse(200, {}, '');
        service.config.region = null;
        service.isGlobalEndpoint = true;
        makeRequest(function() {});
        expect(errorHandler).not.toHaveBeenCalled();
        return delete service.isGlobalEndpoint;
      });
    });
    describe('build', function() {
      return it('takes the request object as a parameter', function() {
        var request, response;
        request = makeRequest();
        request.on('build', function(req) {
          expect(req).toBe(request);
          throw "ERROR";
        });
        response = request.send(function() {});
        return expect(response.error).toEqual("ERROR");
      });
    });
    describe('afterBuild', function() {
      var contentLength, sendRequest;
      sendRequest = function(body) {
        var request;
        request = makeRequest();
        request.removeAllListeners('sign');
        request.on('build', function(req) {
          return req.httpRequest.body = body;
        });
        request.build();
        return request;
      };
      contentLength = function(body) {
        return sendRequest(body).httpRequest.headers['Content-Length'];
      };
      it('builds Content-Length in the request headers for string content', function() {
        return expect(contentLength('FOOBAR')).toEqual(6);
      });
      it('builds Content-Length for string "0"', function() {
        return expect(contentLength('0')).toEqual(1);
      });
      it('builds Content-Length for utf-8 string body', function() {
        return expect(contentLength('tï№')).toEqual(6);
      });
      it('builds Content-Length for buffer body', function() {
        return expect(contentLength(new AWS.util.Buffer('tï№'))).toEqual(6);
      });
      if (AWS.util.isNode()) {
        return it('builds Content-Length for file body', function() {
          var file, fileLen, fs;
          fs = require('fs');
          file = fs.createReadStream(__filename);
          fileLen = fs.lstatSync(file.path).size;
          return expect(contentLength(file)).toEqual(fileLen);
        });
      }
    });
    describe('sign', function() {
      it('takes the request object as a parameter', function() {
        var request, response;
        request = makeRequest();
        request.on('sign', function(req) {
          expect(req).toBe(request);
          throw "ERROR";
        });
        response = request.send(function() {});
        return expect(response.error).toEqual("ERROR");
      });
      it('uses the api.signingName if provided', function() {
        var request, response;
        service.api.signingName = 'SIGNING_NAME';
        spyOn(AWS.Signers.RequestSigner, 'getVersion').andCallFake(function() {
          return function(req, signingName) {
            throw signingName;
          };
        });
        request = makeRequest();
        response = request.send(function() {});
        expect(response.error).toEqual('SIGNING_NAME');
        return delete service.api.signingName;
      });
      return it('uses the api.endpointPrefix if signingName not provided', function() {
        var request, response;
        spyOn(AWS.Signers.RequestSigner, 'getVersion').andCallFake(function() {
          return function(req, signingName) {
            throw signingName;
          };
        });
        request = makeRequest();
        response = request.send(function() {});
        return expect(response.error).toEqual('mockservice');
      });
    });
    describe('send', function() {
      it('passes httpOptions from config', function() {
        var options;
        options = {};
        spyOn(AWS.HttpClient, 'getInstance').andReturn({
          handleRequest: function(req, opts) {
            options = opts;
            return new AWS.SequentialExecutor();
          }
        });
        service.config.httpOptions = {
          timeout: 15
        };
        service.config.maxRetries = 0;
        makeRequest(function() {});
        return expect(options.timeout).toEqual(15);
      });
      it('signs only once in normal case', function() {
        var request, signHandler;
        signHandler = jasmine.createSpy('sign');
        helpers.mockHttpResponse(200, {}, ['data']);
        request = makeRequest();
        request.on('sign', signHandler);
        request.build();
        request.signedAt = new Date(request.signedAt - 60 * 5 * 1000);
        request.send();
        return expect(signHandler.callCount).toEqual(1);
      });
      return it('resigns if it took more than 10 min to get to send', function() {
        var request, signHandler;
        signHandler = jasmine.createSpy('sign');
        helpers.mockHttpResponse(200, {}, ['data']);
        request = makeRequest();
        request.on('sign', signHandler);
        request.build();
        request.signedAt = new Date(request.signedAt - 60 * 12 * 1000);
        request.send();
        return expect(signHandler.callCount).toEqual(2);
      });
    });
    describe('httpData', function() {
      beforeEach(function() {
        return helpers.mockHttpResponse(200, {}, ['FOO', 'BAR', 'BAZ', 'QUX']);
      });
      it('emits httpData event on each chunk', function() {
        var calls, request;
        calls = [];
        request = makeRequest();
        request.on('httpData', function(chunk) {
          return calls.push(chunk.toString());
        });
        request.send();
        return expect(calls).toEqual(['FOO', 'BAR', 'BAZ', 'QUX']);
      });
      return it('does not clear default httpData event if another is added', function() {
        var request, response;
        request = makeRequest();
        request.on('httpData', function() {});
        response = request.send();
        return expect(response.httpResponse.body.toString()).toEqual('FOOBARBAZQUX');
      });
    });
    if (AWS.util.isNode() && AWS.HttpClient.streamsApiVersion > 1) {
      describe('httpDownloadProgress', function() {
        beforeEach(function() {
          return helpers.mockHttpResponse(200, {
            'content-length': 12
          }, ['FOO', 'BAR', 'BAZ', 'QUX']);
        });
        return it('emits httpDownloadProgress for each chunk', function() {
          var progress, request;
          progress = [];
          request = makeRequest();
          request.on('httpDownloadProgress', function(p) {
            return progress.push(p);
          });
          request.send();
          expect(progress[0]).toEqual({
            loaded: 3,
            total: 12
          });
          expect(progress[1]).toEqual({
            loaded: 6,
            total: 12
          });
          expect(progress[2]).toEqual({
            loaded: 9,
            total: 12
          });
          return expect(progress[3]).toEqual({
            loaded: 12,
            total: 12
          });
        });
      });
    }
    describe('retry', function() {
      it('retries a request with a set maximum retries', function() {
        var request, response, sendHandler;
        sendHandler = jasmine.createSpy('send');
        service.config.maxRetries = 10;
        helpers.mockHttpResponse({
          code: 'NetworkingError',
          message: 'Cannot connect'
        });
        request = makeRequest();
        request.on('send', sendHandler);
        response = request.send(function() {});
        expect(retryHandler).toHaveBeenCalled();
        expect(errorHandler).toHaveBeenCalled();
        expect(completeHandler).toHaveBeenCalled();
        expect(successHandler).not.toHaveBeenCalled();
        expect(response.retryCount).toEqual(service.config.maxRetries);
        return expect(sendHandler.calls.length).toEqual(service.config.maxRetries + 1);
      });
      it('retries with falloff', function() {
        helpers.mockHttpResponse({
          code: 'NetworkingError',
          message: 'Cannot connect'
        });
        makeRequest(function() {});
        return expect(delays).toEqual([30, 60, 120]);
      });
      it('uses retry from error.retryDelay property', function() {
        var request, response;
        helpers.mockHttpResponse({
          code: 'NetworkingError',
          message: 'Cannot connect'
        });
        request = makeRequest();
        request.on('retry', function(resp) {
          return resp.error.retryDelay = 17;
        });
        response = request.send(function() {});
        return expect(delays).toEqual([17, 17, 17]);
      });
      it('retries if status code is >= 500', function() {
        helpers.mockHttpResponse(500, {}, '');
        return makeRequest(function(err) {
          expect(err.code).toEqual(500);
          expect(err.message).toEqual(null);
          expect(err.statusCode).toEqual(500);
          expect(err.retryable).toEqual(true);
          return expect(this.retryCount).toEqual(service.config.maxRetries);
        });
      });
      it('should not emit error if retried fewer than maxRetries', function() {
        var response;
        helpers.mockIntermittentFailureResponse(2, 200, {}, 'foo');
        response = makeRequest(function() {});
        expect(totalWaited).toEqual(90);
        expect(response.retryCount).toBeLessThan(service.config.maxRetries);
        expect(response.data).toEqual('foo');
        return expect(errorHandler).not.toHaveBeenCalled();
      });
      ['ExpiredToken', 'ExpiredTokenException', 'RequestExpired'].forEach(function(name) {
        return it('invalidates expired credentials and retries', function() {
          var creds, response;
          spyOn(AWS.HttpClient, 'getInstance');
          AWS.HttpClient.getInstance.andReturn({
            handleRequest: function(req, opts, cb, errCb) {
              if (req.headers.Authorization.match('Credential=INVALIDKEY')) {
                helpers.mockHttpSuccessfulResponse(403, {}, name, cb);
              } else {
                helpers.mockHttpSuccessfulResponse(200, {}, 'DATA', cb);
              }
              return new AWS.SequentialExecutor();
            }
          });
          creds = {
            numCalls: 0,
            expired: false,
            accessKeyId: 'INVALIDKEY',
            secretAccessKey: 'INVALIDSECRET',
            get: function(cb) {
              if (this.expired) {
                this.numCalls += 1;
                this.expired = false;
                this.accessKeyId = 'VALIDKEY' + this.numCalls;
                this.secretAccessKey = 'VALIDSECRET' + this.numCalls;
              }
              return cb();
            }
          };
          service.config.credentials = creds;
          response = makeRequest(function() {});
          expect(response.retryCount).toEqual(1);
          expect(creds.accessKeyId).toEqual('VALIDKEY1');
          return expect(creds.secretAccessKey).toEqual('VALIDSECRET1');
        });
      });
      [301, 307].forEach(function(code) {
        return it('attempts to redirect on ' + code + ' responses', function() {
          var response;
          helpers.mockHttpResponse(code, {
            location: 'http://redirected'
          }, '');
          service.config.maxRetries = 0;
          service.config.maxRedirects = 5;
          response = makeRequest(function() {});
          expect(response.request.httpRequest.endpoint.host).toEqual('redirected');
          expect(response.error.retryable).toEqual(true);
          expect(response.redirectCount).toEqual(service.config.maxRedirects);
          return expect(delays).toEqual([0, 0, 0, 0, 0]);
        });
      });
      return it('does not redirect if 3xx is missing location header', function() {
        var response;
        helpers.mockHttpResponse(304, {}, '');
        service.config.maxRetries = 0;
        response = makeRequest(function() {});
        expect(response.request.httpRequest.endpoint.host).not.toEqual('redirected');
        return expect(response.error.retryable).toEqual(false);
      });
    });
    describe('success', function() {
      return it('emits success on a successful response', function() {
        var response;
        helpers.mockHttpResponse(200, {}, 'Success!');
        response = makeRequest(function() {});
        expect(retryHandler).not.toHaveBeenCalled();
        expect(errorHandler).not.toHaveBeenCalled();
        expect(completeHandler).toHaveBeenCalled();
        expect(successHandler).toHaveBeenCalled();
        return expect(response.retryCount).toEqual(0);
      });
    });
    describe('error', function() {
      it('emits error if error found and should not be retrying', function() {
        var response;
        helpers.mockHttpResponse(400, {}, '');
        response = makeRequest(function() {});
        expect(retryHandler).toHaveBeenCalled();
        expect(errorHandler).toHaveBeenCalled();
        expect(completeHandler).toHaveBeenCalled();
        expect(successHandler).not.toHaveBeenCalled();
        return expect(response.retryCount).toEqual(0);
      });
      return it('emits error if an error is set in extractError', function() {
        var error, extractDataHandler, request, response;
        error = {
          code: 'ParseError',
          message: 'error message'
        };
        extractDataHandler = jasmine.createSpy('extractData');
        helpers.mockHttpResponse(400, {}, '');
        request = makeRequest();
        request.on('extractData', extractDataHandler);
        request.on('extractError', function(resp) {
          return resp.error = error;
        });
        response = request.send(function() {});
        expect(response.error).toBe(error);
        expect(extractDataHandler).not.toHaveBeenCalled();
        expect(retryHandler).toHaveBeenCalled();
        expect(errorHandler).toHaveBeenCalled();
        return expect(completeHandler).toHaveBeenCalled();
      });
    });
    describe('logging', function() {
      var data, logfn, logger, match;
      data = null;
      logger = null;
      logfn = function(d) {
        return data += d;
      };
      match = /\[AWS mock 200 .* 0 retries\] mockMethod\(.*foo.*bar.*\)/;
      beforeEach(function() {
        data = '';
        logger = {};
        return service = new MockService({
          logger: logger
        });
      });
      it('does nothing if logging is off', function() {
        service = new MockService({
          logger: null
        });
        helpers.mockHttpResponse(200, {}, []);
        makeRequest().send();
        return expect(completeHandler).toHaveBeenCalled();
      });
      it('calls .log() on logger if it is available', function() {
        helpers.mockHttpResponse(200, {}, []);
        logger.log = logfn;
        makeRequest().send();
        return expect(data).toMatch(match);
      });
      return it('calls .write() on logger if it is available', function() {
        helpers.mockHttpResponse(200, {}, []);
        logger.write = logfn;
        makeRequest().send();
        return expect(data).toMatch(match);
      });
    });
    return describe('terminal callback error handling', function() {
      describe('without domains', function() {
        it('emits uncaughtException', function() {
          helpers.mockHttpResponse(200, {}, []);
          expect(function() {
            return makeRequest(function() {
              return invalidCode;
            });
          }).toThrow();
          expect(completeHandler).toHaveBeenCalled();
          expect(errorHandler).not.toHaveBeenCalled();
          return expect(retryHandler).not.toHaveBeenCalled();
        });
        return ['error', 'complete'].forEach(function(evt) {
          return it('raise exceptions from terminal ' + evt + ' events', function() {
            var request;
            helpers.mockHttpResponse(500, {}, []);
            request = makeRequest();
            expect(function() {
              return request.send(function() {
                return invalidCode;
              });
            }).toThrow();
            return expect(completeHandler).toHaveBeenCalled();
          });
        });
      });
      if (AWS.util.isNode()) {
        return describe('with domains', function() {
          it('sends error raised from complete event to a domain', function() {
            var d, result;
            result = false;
            d = require('domain').create();
            if (d.run) {
              d.enter();
              d.on('error', function(e) {
                return result = e;
              });
              return d.run(function() {
                var request;
                helpers.mockHttpResponse(200, {}, []);
                request = makeRequest();
                request.on('complete', function() {
                  return invalidCode;
                });
                expect(function() {
                  return request.send();
                }).not.toThrow();
                expect(completeHandler).toHaveBeenCalled();
                expect(retryHandler).not.toHaveBeenCalled();
                expect(result.name).toEqual('ReferenceError');
                return d.exit();
              });
            }
          });
          it('does not leak service error into domain', function() {
            var d, result;
            result = false;
            d = require('domain').create();
            if (d.run) {
              d.on('error', function(e) {
                return result = e;
              });
              d.enter();
              return d.run(function() {
                helpers.mockHttpResponse(500, {}, []);
                makeRequest().send();
                expect(completeHandler).toHaveBeenCalled();
                expect(result).toEqual(false);
                return d.exit();
              });
            }
          });
          return it('supports inner domains', function() {
            var Domain, done, err, gotInnerError, gotOuterError, outerDomain;
            helpers.mockHttpResponse(200, {}, []);
            done = false;
            err = new ReferenceError();
            gotOuterError = false;
            gotInnerError = false;
            Domain = require("domain");
            outerDomain = Domain.create();
            outerDomain.on('error', function() {
              return gotOuterError = true;
            });
            if (outerDomain.run) {
              outerDomain.enter();
              return outerDomain.run(function() {
                var innerDomain, request;
                request = makeRequest();
                innerDomain = Domain.create();
                innerDomain.enter();
                innerDomain.add(request);
                innerDomain.on('error', function() {
                  return gotInnerError = true;
                });
                runs(function() {
                  return request.send(function() {
                    return innerDomain.run(function() {
                      done = true;
                      throw err;
                    });
                  });
                });
                waitsFor(function() {
                  return done;
                });
                return runs(function() {
                  expect(gotOuterError).toEqual(false);
                  expect(gotInnerError).toEqual(true);
                  expect(err.domainThrown).toEqual(false);
                  expect(err.domain).toEqual(innerDomain);
                  innerDomain.exit();
                  return outerDomain.exit();
                });
              });
            }
          });
        });
      }
    });
  });

}).call(this);
