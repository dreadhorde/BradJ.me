(function() {
  var AWS, Buffer;

  AWS = require('./helpers').AWS;

  Buffer = AWS.util.Buffer;

  describe('uriEscape', function() {
    var e;
    e = AWS.util.uriEscape;
    it('escapes spaces as %20', function() {
      return expect(e('a b')).toEqual('a%20b');
    });
    it('escapes + as %2B', function() {
      return expect(e('a+b')).toEqual('a%2Bb');
    });
    it('escapes / as %2F', function() {
      return expect(e('a/b')).toEqual('a%2Fb');
    });
    it('escapes \' as %27', function() {
      return expect(e('a\'b')).toEqual('a%27b');
    });
    it('escapes * as %2A', function() {
      return expect(e('a*b')).toEqual('a%2Ab');
    });
    it('does not escape ~', function() {
      return expect(e('a~b')).toEqual('a~b');
    });
    return it('encodes utf8 characters', function() {
      return expect(e('ёŝ')).toEqual('%D1%91%C5%9D');
    });
  });

  describe('uriEscapePath', function() {
    var e;
    e = AWS.util.uriEscapePath;
    it('does not escape forward slashes', function() {
      var s;
      s = 'a&b/x=y/1+2/m?n';
      return expect(e(s)).toEqual('a%26b/x%3Dy/1%2B2/m%3Fn');
    });
    return it('leaves leading and trailing forward slashes in place', function() {
      var s;
      s = '/ab cd/';
      return expect(e(s)).toEqual('/ab%20cd/');
    });
  });

  describe('AWS.util.queryParamsToString', function() {
    var qpts;
    qpts = AWS.util.queryParamsToString;
    it('sorts query parameters before stringifying', function() {
      return expect(qpts({
        c: '1',
        b: '2',
        a: '3'
      })).toEqual('a=3&b=2&c=1');
    });
    it('handles empty values', function() {
      return expect(qpts({
        a: '',
        b: '2'
      })).toEqual('a=&b=2');
    });
    it('handles null/undefined values', function() {
      return expect(qpts({
        a: void 0,
        b: null
      })).toEqual('a&b');
    });
    it('calls uriEscape on each name and value', function() {
      var spy;
      spy = spyOn(AWS.util, 'uriEscape').andCallThrough();
      qpts({
        c: '1',
        b: '2',
        a: '3'
      });
      return expect(spy.calls.length).toEqual(6);
    });
    it('handles values as lists', function() {
      return expect(qpts({
        a: ['1', '2', '3'],
        b: '4'
      })).toEqual('a=1&a=2&a=3&b=4');
    });
    it('escapes list values', function() {
      return expect(qpts({
        a: ['+', '&', '*'],
        b: '4'
      })).toEqual('a=%26&a=%2A&a=%2B&b=4');
    });
    return it('does not provide value if value is null', function() {
      return expect(qpts({
        a: null,
        b: null
      })).toEqual('a&b');
    });
  });

  describe('AWS.util.date', function() {
    var util;
    util = AWS.util.date;
    describe('getDate', function() {
      return it('should return current date by default', function() {
        var mock, now, oldDate;
        oldDate = Date;
        now = {};
        mock = jasmine.createSpy().andReturn(now);
        typeof window !== 'undefined' ? (window.Date = mock) : (Date = mock);;
        expect(util.getDate()).toBe(now);
        return typeof window !== 'undefined' ? (window.Date = oldDate) : (Date = oldDate);;
      });
    });
    describe('iso8601', function() {
      it('should return date formatted as YYYYMMDDTHHnnssZ', function() {
        var date;
        date = new Date(600000);
        date.setMilliseconds(0);
        spyOn(util, 'getDate').andCallFake(function() {
          return date;
        });
        return expect(util.iso8601()).toEqual('1970-01-01T00:10:00.000Z');
      });
      return it('should allow date parameter', function() {
        var date;
        date = new Date(660000);
        date.setMilliseconds(0);
        return expect(util.iso8601(date)).toEqual('1970-01-01T00:11:00.000Z');
      });
    });
    describe('rfc822', function() {
      it('should return date formatted as YYYYMMDDTHHnnssZ', function() {
        var date;
        date = new Date(600000);
        date.setMilliseconds(0);
        spyOn(util, 'getDate').andCallFake(function() {
          return date;
        });
        return expect(util.rfc822()).toMatch(/^Thu, 0?1 Jan 1970 00:10:00 (GMT|UTC)$/);
      });
      return it('should allow date parameter', function() {
        var date;
        date = new Date(660000);
        date.setMilliseconds(0);
        return expect(util.rfc822(date)).toMatch(/^Thu, 0?1 Jan 1970 00:11:00 (GMT|UTC)$/);
      });
    });
    return describe('unixTimestamp', function() {
      it('should return date formatted as unix timestamp', function() {
        var date;
        date = new Date(600000);
        date.setMilliseconds(0);
        spyOn(util, 'getDate').andCallFake(function() {
          return date;
        });
        return expect(util.unixTimestamp()).toEqual(600);
      });
      it('should allow date parameter', function() {
        var date;
        date = new Date(660000);
        date.setMilliseconds(0);
        return expect(util.unixTimestamp(date)).toEqual(660);
      });
      return it('should return date formatted as unix timestamp with milliseconds', function() {
        spyOn(util, 'getDate').andCallFake(function() {
          return new Date(600123);
        });
        return expect(util.unixTimestamp()).toEqual(600.123);
      });
    });
  });

  describe('AWS.util.string', function() {
    var len;
    len = AWS.util.string.byteLength;
    return describe('byteLength', function() {
      it('handles null/undefined objects', function() {
        expect(len(void 0)).toEqual(0);
        return expect(len(null)).toEqual(0);
      });
      it('handles buffer input', function() {
        return expect(len(new Buffer('∂ƒ©∆'))).toEqual(10);
      });
      it('handles string input', function() {
        expect(len('')).toEqual(0);
        return expect(len('∂ƒ©∆')).toEqual(10);
      });
      if (AWS.util.isNode()) {
        it('handles file object input (path property)', function() {
          var file, fileLen, fs;
          fs = require('fs');
          file = fs.createReadStream(__filename);
          fileLen = fs.lstatSync(file.path).size;
          expect(len(file)).toEqual(fileLen);
          return expect(len({
            path: __filename
          })).toEqual(fileLen);
        });
      }
      it('fails if input is not a string, buffer, or file', function() {
        var e, err;
        err = null;
        try {
          len(3.14);
        } catch (error) {
          e = error;
          err = e;
        }
        expect(err.message).toEqual('Cannot determine length of 3.14');
        return expect(err.object).toBe(3.14);
      });
      return it('ignores path property unless it is a string', function() {
        var e, err, object;
        object = {};
        err = null;
        try {
          len(object);
        } catch (error) {
          e = error;
          err = e;
        }
        expect(err.message).toMatch(/Cannot determine length of /);
        return expect(err.object).toBe(object);
      });
    });
  });

  describe('AWS.util.ini', function() {
    return describe('parse', function() {
      return it('parses an ini file', function() {
        var ini, map;
        ini = '; comment at the beginning of the line\n[section1] ; comment at end of line\ninvalidline\nkey1=value1 ; another comment\n  key2 = value2;value3\n[emptysection]';
        map = AWS.util.ini.parse(ini);
        expect(map.section1.key1).toEqual('value1');
        expect(map.section1.key2).toEqual('value2;value3');
        return expect(map.emptysection).toBe(void 0);
      });
    });
  });

  describe('AWS.util.buffer', function() {
    return describe('concat', function() {
      return it('concatenates a list of buffers', function() {
        var buffer1, buffer2, buffer3;
        buffer1 = new Buffer('abcdefg');
        buffer2 = new Buffer('hijklmn');
        buffer3 = AWS.util.buffer.concat([buffer1, buffer2]);
        expect(buffer3.length).toEqual(14);
        return expect(buffer3.toString()).toEqual('abcdefghijklmn');
      });
    });
  });

  describe('AWS.util.crypto', function() {
    var util;
    util = AWS.util.crypto;
    describe('crc32', function() {
      it('returns the correct CRC32 value for binary data', function() {
        var buffer, i, j, ref;
        buffer = new Buffer(4433);
        for (i = j = 0, ref = buffer.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          buffer.writeUInt8(i % 256, i);
        }
        return expect(util.crc32(buffer)).toEqual(899332870);
      });
      return it('handles String values', function() {
        var string;
        string = '{"ConsumedCapacityUnits":1.0}';
        return expect(util.crc32(string)).toEqual(2614884069);
      });
    });
    describe('toHex', function() {
      return it('should convert binary data to hex string', function() {
        return expect(util.toHex('ABC')).toEqual('414243');
      });
    });
    describe('hmac', function() {
      var input, key, result;
      input = 'foo';
      key = 'KEY';
      result = '116a3725a3540067a09e4dba64bb6b3fb27b4d98a1a2e2dbcb8b4cffa73585d5';
      it('should return a keyed hash as a binary digest', function() {
        var expected;
        expected = util.hmac(key, input);
        return expect(util.toHex(expected)).toEqual(result);
      });
      it('should return a keyed hash as hex digest', function() {
        var expected;
        expected = util.hmac(key, input, 'hex');
        return expect(expected).toEqual(result);
      });
      it('accepts the crypto function as an argument', function() {
        var r;
        r = util.hmac('secret', 'the quick brown fox', 'base64', 'sha1');
        return expect(r).toEqual('z1BzGT+uG/2qGzE1UHb5m/skn1E=');
      });
      return it('accepts UTF-8 input for string', function() {
        var r;
        r = util.hmac('foo', 'å∆ç∂', 'hex');
        return expect(r).toEqual('bc11556145cbe4935ba187b9f8ba0c12bae2c866e5795013dfe2d08cabc33e13');
      });
    });
    describe('sha256', function() {
      var input, result;
      input = 'foo';
      result = '2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae';
      it('should return binary data hashed with sha256', function() {
        var expected;
        expected = util.sha256(input);
        return expect(util.toHex(expected)).toEqual(result);
      });
      it('should return hex data hashed with sha256', function() {
        var expected;
        expected = util.sha256(input, 'hex');
        return expect(expected).toEqual(result);
      });
      return it('accepts UTF-8 input', function() {
        var r;
        r = util.sha256('ß∂ƒ©', 'hex');
        return expect(r).toEqual('3c01ddd413d2cacac59a255e4aade0d9058a8a9ea8b2dfe5bb2dc4ed132b4139');
      });
    });
    return describe('md5', function() {
      var input, result;
      input = 'foo';
      result = 'acbd18db4cc2f85cedef654fccc4a4d8';
      it('should return binary data hashed with md5', function() {
        var expected;
        expected = util.md5(input);
        return expect(util.toHex(expected)).toEqual(result);
      });
      it('should return hex data hashed with md5', function() {
        var expected;
        expected = util.md5(input, 'hex');
        return expect(expected).toEqual(result);
      });
      return it('accepts UTF-8 input', function() {
        var r;
        r = util.md5('ￃ', 'hex');
        return expect(r).toEqual('b497dbbe19fb58cddaeef11f9d40804c');
      });
    });
  });

  describe('AWS.util.each', function() {
    it('should iterate over a hash', function() {
      var parts;
      parts = [];
      AWS.util.each({
        a: 1,
        b: 2,
        c: 3
      }, function(key, item) {
        return parts.push([key + '_', item + 1]);
      });
      return expect(parts).toEqual([['a_', 2], ['b_', 3], ['c_', 4]]);
    });
    it('should iterate over an array', function() {
      var total;
      total = 0;
      AWS.util.each([1, 2, 3], function(idx, item) {
        return total += item;
      });
      return expect(total).toEqual(6);
    });
    it('should ignore inherited properties', function() {
      var obj, objCtor, parts;
      objCtor = function() {
        this.a = 1;
        this.b = 2;
        return this.c = 3;
      };
      objCtor.prototype = {
        d: 4,
        e: 5,
        f: 6
      };
      obj = new objCtor();
      parts = [];
      AWS.util.each(obj, function(key, item) {
        return parts.push([key + '_', item + 1]);
      });
      return expect(parts).toEqual([['a_', 2], ['b_', 3], ['c_', 4]]);
    });
    it('callback should not change "this" scope', function() {
      return new function() {
        var self;
        this["class"] = 'MyClass';
        self = this;
        return AWS.util.each.apply(this, [
          [1, 2, 3], function() {
            return expect(this).toBe(self);
          }
        ]);
      };
    });
    return it('can abort out of loop', function() {
      var string;
      string = '';
      AWS.util.each({
        a: 1,
        b: 2,
        c: 3
      }, function(key, item) {
        if (item === 2) {
          return AWS.util.abort;
        }
        return string += key;
      });
      return expect(string).toEqual('a');
    });
  });

  describe('AWS.util.arrayEach', function() {
    it('should iterate over arrays', function() {
      var total;
      total = 0;
      AWS.util.arrayEach([1, 2, 3], function(item) {
        return total += item;
      });
      return expect(total).toEqual(6);
    });
    it('should pass index as second parameter', function() {
      var lastIndex;
      lastIndex = null;
      return AWS.util.arrayEach([1, 2, 3], function(item, idx) {
        expect(typeof idx).toEqual('number');
        if (lastIndex !== null) {
          expect(lastIndex).toEqual(idx - 1);
        }
        return lastIndex = idx;
      });
    });
    return it('can abort out of loop', function() {
      var total;
      total = 0;
      AWS.util.arrayEach([1, 2, 3], function(item, idx) {
        if (idx === 1) {
          return AWS.util.abort;
        }
        return total += item;
      });
      return expect(total).toEqual(1);
    });
  });

  describe('AWS.util.copy', function() {
    it('does not copy null or undefined', function() {
      expect(AWS.util.copy(null)).toEqual(null);
      return expect(AWS.util.copy(void 0)).toEqual(void 0);
    });
    it('should perform a shallow copy of an object', function() {
      var copied, obj;
      obj = {
        a: 1,
        b: 2,
        c: 3
      };
      copied = AWS.util.copy(obj);
      expect(copied).not.toBe(obj);
      return expect(copied).toEqual({
        a: 1,
        b: 2,
        c: 3
      });
    });
    return it('should copy inherited properties', function() {
      var copied, obj, objCtor;
      objCtor = function() {
        this.a = 1;
        this.b = 2;
        return this.c = 3;
      };
      objCtor.prototype = {
        d: 4
      };
      obj = new objCtor();
      copied = AWS.util.copy(obj);
      expect(copied).not.toBe(obj);
      return expect(copied).toEqual({
        a: 1,
        b: 2,
        c: 3,
        d: 4
      });
    });
  });

  describe('AWS.util.merge', function() {
    return it('should merge an object into another and return new object', function() {
      var newObj, obj;
      obj = {
        a: 1,
        b: 2,
        c: 3
      };
      newObj = AWS.util.merge(obj, {
        d: 4,
        e: 5,
        a: 6
      });
      expect(newObj).toEqual({
        a: 6,
        b: 2,
        c: 3,
        d: 4,
        e: 5
      });
      return expect(obj).toEqual({
        a: 1,
        b: 2,
        c: 3
      });
    });
  });

  describe('AWS.util.update', function() {
    it('should merge an object into another', function() {
      var obj;
      obj = {
        a: 1,
        b: 2,
        c: 3
      };
      AWS.util.update(obj, {
        d: 4,
        e: 5,
        a: 6
      });
      return expect(obj).toEqual({
        a: 6,
        b: 2,
        c: 3,
        d: 4,
        e: 5
      });
    });
    return it('should return the merged object', function() {
      var obj;
      obj = {
        a: 1,
        b: 2
      };
      return expect(AWS.util.update(obj, {
        c: 3
      })).toBe(obj);
    });
  });

  describe('AWS.util.inherit', function() {
    it('should inherit an object and append features', function() {
      var Base, Derived, derived;
      Base = function(value) {
        return this.defaultValue = value;
      };
      Base.prototype = {
        main: function() {
          return 'main';
        },
        other: 'other'
      };
      Derived = AWS.util.inherit(Base, {
        constructor: function(value) {
          return Base.apply(this, [value + 5]);
        },
        main: function() {
          return 'notMain';
        },
        foo: function() {
          return 'bar';
        }
      });
      derived = new Derived(5);
      expect(derived instanceof Base).toBeTruthy();
      expect(derived.constructor).toBe(Derived);
      expect(derived.main()).toEqual('notMain');
      expect(derived.other).toEqual('other');
      expect(derived.defaultValue).toEqual(10);
      return expect(derived.foo()).toEqual('bar');
    });
    return it('should create pass-through constructor if not defined', function() {
      var Base, Derived, derived;
      Base = AWS.util.inherit({
        constructor: jasmine.createSpy()
      });
      Derived = AWS.util.inherit(Base, {
        other: true
      });
      derived = new Derived(1, 2, 'three');
      expect(derived.other).toEqual(true);
      return expect(Base.prototype.constructor).toHaveBeenCalledWith(1, 2, 'three');
    });
  });

  describe('AWS.util.mixin', function() {
    it('copies properties to other object prototype', function() {
      var obj;
      obj = {
        prototype: {
          a: 1,
          b: 2
        }
      };
      AWS.util.mixin(obj, {
        prototype: {
          b: 3,
          c: 4
        }
      });
      return expect(obj.prototype).toEqual({
        a: 1,
        b: 3,
        c: 4
      });
    });
    it('resets prototype constructor', function() {
      var obj;
      obj = {
        prototype: {
          constructor: 'PASS'
        }
      };
      AWS.util.mixin(obj, {
        prototype: {
          constructor: 'FAIL'
        }
      });
      return expect(obj.prototype).toEqual({
        constructor: 'PASS'
      });
    });
    return it('returns original klass', function() {
      var obj, out;
      obj = {
        prototype: {
          foo: 1
        }
      };
      out = AWS.util.mixin(obj, {
        prototype: {
          bar: 2
        }
      });
      return expect(out).toBe(obj);
    });
  });

  describe('AWS.util.isType', function() {
    it('accepts function for type', function() {
      return expect(AWS.util.isType([], Array)).toEqual(true);
    });
    return it('accepts string for type', function() {
      return expect(AWS.util.isType([], 'Array')).toEqual(true);
    });
  });

  describe('AWS.util.isEmpty', function() {
    it('returns true when passed an empty object literal', function() {
      return expect(AWS.util.isEmpty({})).toEqual(true);
    });
    return it('returns true when passed a non-empty object literal', function() {
      return expect(AWS.util.isEmpty({
        a: 1
      })).toEqual(false);
    });
  });

  describe('AWS.util.error', function() {
    it('returns the created error object with extra options', function() {
      var err, origError;
      origError = new Error();
      err = AWS.util.error(origError, {
        message: 'msg',
        code: 'code'
      });
      expect(err).toBe(origError);
      expect(err.message).toEqual('msg');
      return expect(err.code).toEqual('code');
    });
    it('accepts missing options', function() {
      var err, origError;
      origError = new Error('ERROR');
      err = AWS.util.error(origError);
      expect(err).toBe(origError);
      return expect(err.message).toEqual('ERROR');
    });
    it('maintains the original error message property', function() {
      var err, origError;
      origError = new Error('ERROR');
      err = AWS.util.error(origError, {
        code: 'code'
      });
      expect(err).toBe(origError);
      expect(err.message).toEqual('ERROR');
      return expect(err.code).toEqual('code');
    });
    return it('keeps track of the old error', function() {
      var err, origError;
      origError = new Error('ERROR');
      origError.value = 1;
      err = AWS.util.error(origError, {
        code: 'code',
        message: 'FOO'
      });
      expect(err.originalError.message).toEqual('ERROR');
      expect(err.originalError.code).toEqual(void 0);
      return expect(err.originalError.value).toEqual(1);
    });
  });

  describe('AWS.util.base64', function() {
    var base64;
    base64 = AWS.util.base64;
    describe('encode', function() {
      return it('encodes the given string', function() {
        expect(base64.encode('foo')).toEqual('Zm9v');
        return expect(base64.encode('ёŝ')).toEqual('0ZHFnQ==');
      });
    });
    return describe('decode', function() {
      return it('decodes the given string', function() {
        expect(base64.decode('Zm9v').toString()).toEqual('foo');
        return expect(base64.decode('0ZHFnQ==').toString()).toEqual('ёŝ');
      });
    });
  });

  describe('AWS.util.jamespath', function() {
    var find, query;
    query = AWS.util.jamespath.query;
    find = AWS.util.jamespath.find;
    describe('query', function() {
      it('can find a toplevel element of a data structure', function() {
        return expect(query('foo', {
          foo: 'value'
        })).toEqual(['value']);
      });
      it('can find a nested element of a data structure', function() {
        return expect(query('foo.bar.baz', {
          foo: {
            bar: {
              baz: 'value'
            }
          }
        })).toEqual(['value']);
      });
      it('can index an element (positive and negative indexes)', function() {
        var data;
        data = {
          foo: {
            bar: [
              {
                baz: 'wrong'
              }, {
                baz: 'right'
              }, {
                baz: 'wrong'
              }
            ]
          }
        };
        expect(query('foo.bar[1].baz', data)).toEqual(['right']);
        return expect(query('foo.bar[-2].baz', data)).toEqual(['right']);
      });
      it('can index an element with wildcard', function() {
        var data;
        data = {
          foo: {
            bar: [
              {
                baz: 'wrong'
              }, {
                baz: 'right'
              }, {
                baz: 'wrong'
              }
            ]
          }
        };
        return expect(query('foo.bar[*].baz', data)).toEqual(['wrong', 'right', 'wrong']);
      });
      it('returns empty array if element is not found', function() {
        var data;
        data = {
          foo: {
            notBar: {
              baz: 'value'
            }
          }
        };
        return expect(query('foo.bar.baz', data)).toEqual([]);
      });
      it('allows multiple expressions to be ORed', function() {
        var data;
        data = {
          foo: {
            key1: 'wrong'
          },
          bar: {
            key2: 'right'
          }
        };
        return expect(query('foo.key2 or bar.key2', data)).toEqual(['right']);
      });
      it('returns multiple matches if a wildcard is used', function() {
        var data;
        data = {
          foo: {
            child1: {
              bar: 'value1'
            },
            child2: {
              bar: 'value2'
            },
            child3: {
              bar: 'value3'
            }
          }
        };
        return expect(query('foo.*.bar', data)).toEqual(['value1', 'value2', 'value3']);
      });
      it('can support wildcard on both token and index', function() {
        var data;
        data = {
          foo: {
            child1: ['value1', 'value2'],
            child2: ['value3'],
            child4: 'notarray'
          }
        };
        return expect(query('foo.*[*]', data)).toEqual(['value1', 'value2', 'value3']);
      });
      return it('can support array flattening', function() {
        var data;
        data = {
          foo: [
            {
              bar: 1
            }, {
              bar: 2
            }, {
              bar: 3
            }
          ]
        };
        return expect(query('foo[].bar', data)).toEqual([1, 2, 3]);
      });
    });
    return describe('find', function() {
      it('returns the first match of query', function() {
        return expect(find('foo.*', {
          foo: {
            bar: 1,
            baz: 2
          }
        })).toEqual(1);
      });
      return it('returns null if no match is found', function() {
        return expect(find('invalid.*', {
          foo: {
            bar: 1,
            baz: 2
          }
        })).toEqual(null);
      });
    });
  });

}).call(this);
