(function() {
  var AWS, Buffer, EventEmitter, MockService, helpers;

  helpers = require('./helpers');

  EventEmitter = require('events').EventEmitter;

  AWS = helpers.AWS;

  MockService = helpers.MockService;

  Buffer = AWS.util.Buffer;

  describe('AWS.Request', function() {
    var service;
    service = null;
    beforeEach(function() {
      return service = new MockService;
    });
    describe('error handling', function() {
      var evt, i, len, ref;
      it('throws errors out of callback', function() {
        helpers.mockHttpResponse(200, {}, '');
        return expect(function() {
          return service.makeRequest('mockMethod', function() {
            throw new Error('error');
          });
        }).toThrow('error');
      });
      ref = ['error', 'success', 'complete'];
      for (i = 0, len = ref.length; i < len; i++) {
        evt = ref[i];
        it('throws errors out of terminal ' + evt + ' event', function() {
          helpers.mockHttpResponse(200, {}, '');
          return expect(function() {
            var req;
            req = service.makeRequest('mockMethod');
            req.on(evt, function() {
              throw new Error('error');
            });
            return req.send();
          }).toThrow('error');
        });
      }
      return it('propagates errors to error event', function() {
        var err;
        helpers.mockHttpResponse(200, {}, '');
        err = null;
        expect(function() {
          var req;
          req = service.makeRequest('mockMethod');
          req.on('extractData', function() {
            throw new Error('error');
          });
          return req.send(function(e) {
            return err = e;
          });
        }).not.toThrow('error');
        return expect(err.message).toEqual('error');
      });
    });
    describe('isPageable', function() {
      beforeEach(function() {
        return service = new AWS.Service({
          apiConfig: new AWS.Model.Api({
            operations: {
              mockMethod: {}
            }
          })
        });
      });
      it('is pageable if it has a pagination config for the operation', function() {
        var request;
        service.api.paginators['mockMethod'] = new AWS.Model.Paginator('mockMethod', {
          limit_key: 'Marker'
        });
        request = service.makeRequest('mockMethod');
        return expect(request.isPageable()).toEqual(true);
      });
      return it('is not pageable if the pagination config does not exist for the operation', function() {
        return expect(service.makeRequest('mockMethod').isPageable()).toEqual(false);
      });
    });
    describe('eachPage', function() {
      beforeEach(function() {
        service = new AWS.Service({
          apiConfig: new AWS.Model.Api({
            operations: {
              mockMethod: {
                input: {
                  type: 'structure',
                  members: {
                    NextToken: {
                      type: 'string'
                    }
                  }
                },
                output: {
                  type: 'structure',
                  members: {
                    NextToken: {
                      type: 'string'
                    },
                    Value: {
                      type: 'integer'
                    }
                  }
                }
              }
            },
            paginators: {
              mockMethod: {
                input_token: 'NextToken',
                output_token: 'NextToken'
              }
            }
          })
        });
        return helpers.mockResponses(service, [
          {
            data: {
              Value: 1,
              NextToken: 'a'
            }
          }, {
            data: {
              Value: 2,
              NextToken: 'b'
            }
          }, {
            data: {
              Value: 3,
              NextToken: 'c'
            }
          }, {
            data: {
              Value: 4
            }
          }
        ]);
      });
      it('can page multiple responses', function() {
        var resps;
        resps = [];
        runs(function() {
          return service.mockMethod().eachPage(function(err, data) {
            return resps.push([err, data]);
          });
        });
        waitsFor(function() {
          return resps.length > 3;
        });
        return runs(function() {
          return expect(resps).toEqual([
            [
              null, {
                Value: 1,
                NextToken: 'a'
              }
            ], [
              null, {
                Value: 2,
                NextToken: 'b'
              }
            ], [
              null, {
                Value: 3,
                NextToken: 'c'
              }
            ], [
              null, {
                Value: 4
              }
            ], [null, null]
          ]);
        });
      });
      it('supports stopping responses if false is returned', function() {
        var resps;
        resps = [];
        runs(function() {
          return service.mockMethod().eachPage(function(err, data) {
            if (resps.length === 2) {
              return false;
            }
            resps.push([err, data]);
            return true;
          });
        });
        waitsFor(function() {
          return resps.length === 2;
        });
        return runs(function() {
          return expect(resps).toEqual([
            [
              null, {
                Value: 1,
                NextToken: 'a'
              }
            ], [
              null, {
                Value: 2,
                NextToken: 'b'
              }
            ]
          ]);
        });
      });
      it('supports asynchronous eachPage calls', function() {
        var resps;
        resps = [];
        runs(function() {
          return service.mockMethod().eachPage(function(err, data, done) {
            return process.nextTick(function() {
              resps.push([err, data]);
              return done();
            });
          });
        });
        waitsFor(function() {
          return resps.length > 3;
        });
        return runs(function() {
          return expect(resps).toEqual([
            [
              null, {
                Value: 1,
                NextToken: 'a'
              }
            ], [
              null, {
                Value: 2,
                NextToken: 'b'
              }
            ], [
              null, {
                Value: 3,
                NextToken: 'c'
              }
            ], [
              null, {
                Value: 4
              }
            ], [null, null]
          ]);
        });
      });
      return it('throws error from eachPage callback', function() {
        var e;
        try {
          return service.mockMethod().eachPage(function() {
            return invalidCode;
          });
        } catch (error1) {
          e = error1;
          return expect(e.name).toEqual('ReferenceError');
        }
      });
    });
    describe('waitFor', function() {
      return it('creates a ResourceWaiter object', function() {
        service.api.waiters = {
          state: {
            operation: 'mockMethod'
          }
        };
        return service.waitFor('state');
      });
    });
    describe('send', function() {
      return it('accepts an optional callback', function() {
        var data, error;
        error = null;
        data = null;
        helpers.mockHttpResponse(200, {}, ['FOO', 'BAR', 'BAZ', 'QUX']);
        runs(function() {
          return service.makeRequest('mockMethod').send(function(e, d) {
            return data = d;
          });
        });
        waitsFor(function() {
          return data;
        });
        return runs(function() {
          return expect(data).toEqual('FOOBARBAZQUX');
        });
      });
    });
    describe('abort', function() {
      return it('allows aborting requests', function() {
        var data, done, error;
        error = null;
        data = null;
        done = null;
        helpers.mockHttpResponse(200, {}, ['FOO', 'BAR', 'BAZ', 'QUX']);
        runs(function() {
          var req;
          req = service.makeRequest('mockMethod');
          req.on('send', function(resp) {
            return req.abort();
          });
          return req.send(function(e, d) {
            done = true;
            error = e;
            return data = d;
          });
        });
        waitsFor(function() {
          return done;
        });
        return runs(function() {
          expect(data).toEqual(null);
          expect(error.code).toEqual('RequestAbortedError');
          return expect(error.message).toMatch(/aborted by user/);
        });
      });
    });
    if (AWS.util.isNode()) {
      return describe('createReadStream', function() {
        it('streams data', function() {
          var data, done;
          data = '';
          done = false;
          helpers.mockHttpResponse(200, {}, ['FOO', 'BAR', 'BAZ', 'QUX']);
          runs(function() {
            var request, s;
            request = service.makeRequest('mockMethod');
            s = request.createReadStream();
            s.on('end', function() {
              return done = true;
            });
            return s.on('data', function(c) {
              return data += c.toString();
            });
          });
          waitsFor(function() {
            return done === true;
          });
          return runs(function() {
            return expect(data).toEqual('FOOBARBAZQUX');
          });
        });
        it('streams2 data (readable event)', function() {
          var data, done;
          if (AWS.HttpClient.streamsApiVersion < 2) {
            return;
          }
          data = '';
          done = false;
          helpers.mockHttpResponse(200, {}, ['FOO', 'BAR', 'BAZ', 'QUX']);
          runs(function() {
            var request, s;
            request = service.makeRequest('mockMethod');
            s = request.createReadStream();
            s.on('end', function() {
              return done = true;
            });
            return s.on('readable', function() {
              var chunk, e;
              try {
                chunk = s.read();
                if (chunk) {
                  return data += chunk;
                }
              } catch (error1) {
                e = error1;
                return console.log(e.stack);
              }
            });
          });
          waitsFor(function() {
            return done === true;
          });
          return runs(function() {
            return expect(data).toEqual('FOOBARBAZQUX');
          });
        });
        it('streams2 data does not hang out while waiting response', function() {
          var data, done;
          if (AWS.HttpClient.streamsApiVersion < 2) {
            return;
          }
          data = '';
          done = false;
          helpers.mockHttpResponse(200, {}, ['FOO', 'BAR', null, null, 'BAZ', 'QUX']);
          runs(function() {
            var request, s;
            request = service.makeRequest('mockMethod');
            s = request.createReadStream();
            s.on('end', function() {
              return done = true;
            });
            return s.on('readable', function() {
              var chunk, e;
              try {
                chunk = s.read();
                if (chunk) {
                  return data += chunk;
                }
              } catch (error1) {
                e = error1;
                return console.log(e.stack);
              }
            });
          });
          waitsFor(function() {
            return done === true;
          });
          return runs(function() {
            return expect(data).toEqual('FOOBARBAZQUX');
          });
        });
        it('does not stream data on failures', function() {
          var data, done, error;
          data = '';
          error = null;
          done = false;
          helpers.mockHttpResponse(404, {}, ['No such file']);
          runs(function() {
            var request, s;
            request = service.makeRequest('mockMethod');
            s = request.createReadStream();
            s.on('end', function() {
              return done = true;
            });
            s.on('error', function(e) {
              error = e;
              return done = true;
            });
            return s.on('data', function(c) {
              return data += c.toString();
            });
          });
          waitsFor(function() {
            return done === true;
          });
          return runs(function() {
            expect(data).toEqual('');
            return expect(error.statusCode).toEqual(404);
          });
        });
        it('retries temporal errors and streams resulting successful response', function() {
          var data, done, error;
          data = '';
          error = null;
          done = false;
          helpers.mockIntermittentFailureResponse(2, 200, {}, ['FOO', 'BAR', 'BAZ', 'QUX']);
          runs(function() {
            var request, s;
            request = service.makeRequest('mockMethod');
            s = request.createReadStream();
            s.on('end', function() {
              return done = true;
            });
            s.on('error', function(e) {
              error = e;
              return done = true;
            });
            return s.on('data', function(c) {
              return data += c.toString();
            });
          });
          waitsFor(function() {
            return done === true;
          });
          return runs(function() {
            expect(data).toEqual('FOOBARBAZQUX');
            return expect(error).toEqual(null);
          });
        });
        it('streams partial data and raises an error', function() {
          var data, done, error, reqError;
          data = '';
          error = null;
          reqError = null;
          done = false;
          spyOn(AWS.HttpClient, 'getInstance');
          AWS.HttpClient.getInstance.andReturn({
            handleRequest: function(req, opts, cb, errCb) {
              req = new EventEmitter();
              req.statusCode = 200;
              req.headers = {};
              cb(req);
              req.emit('headers', 200, {});
              AWS.util.arrayEach(['FOO', 'BAR', 'BAZ'], function(str) {
                return req.emit('data', new Buffer(str));
              });
              errCb(new Error('fail'));
              return req;
            }
          });
          runs(function() {
            var request, s;
            request = service.makeRequest('mockMethod');
            request.on('error', function(e) {
              return reqError = e;
            });
            request.on('complete', function() {
              return done = true;
            });
            s = request.createReadStream();
            s.on('error', function(e) {
              return error = e;
            });
            return s.on('data', function(c) {
              return data += c.toString();
            });
          });
          waitsFor(function() {
            return done === true;
          });
          return runs(function() {
            expect(data).toEqual('FOOBARBAZ');
            expect(error.message).toEqual('fail');
            return expect(reqError.message).toEqual('fail');
          });
        });
        return it('fails if retry occurs in the middle of a failing stream', function() {
          var data, error, reqError, resp, retryCount;
          data = '';
          error = null;
          reqError = null;
          resp = null;
          retryCount = 0;
          spyOn(AWS.HttpClient, 'getInstance');
          AWS.HttpClient.getInstance.andReturn({
            handleRequest: function(req, opts, cb, errCb) {
              req = new EventEmitter();
              req.statusCode = 200;
              req.headers = {};
              process.nextTick(function() {
                cb(req);
                req.emit('headers', 200, {});
                AWS.util.arrayEach(['FOO', 'BAR', 'BAZ', 'QUX'], function(str) {
                  if (str === 'BAZ' && retryCount < 1) {
                    process.nextTick(function() {
                      retryCount += 1;
                      return errCb({
                        code: 'NetworkingError',
                        message: 'FAIL!',
                        retryable: true
                      });
                    });
                    return AWS.util.abort;
                  } else {
                    return process.nextTick(function() {
                      return req.emit('data', new Buffer(str));
                    });
                  }
                });
                if (retryCount >= 1) {
                  return process.nextTick(function() {
                    return req.emit('end');
                  });
                }
              });
              return req;
            }
          });
          runs(function() {
            var request, s;
            request = service.makeRequest('mockMethod');
            request.on('error', function(e) {
              return reqError = e;
            });
            request.on('complete', function(r) {
              return resp = r;
            });
            s = request.createReadStream();
            s.on('error', function(e) {
              return error = e;
            });
            return s.on('data', function(c) {
              return data += c.toString();
            });
          });
          waitsFor(function() {
            return resp !== null;
          });
          return runs(function() {
            expect(data).toEqual('FOOBAR');
            expect(error.code).toEqual('NetworkingError');
            expect(reqError.code).toEqual('NetworkingError');
            expect(reqError.hostname).toEqual('mockservice.mock-region.amazonaws.com');
            expect(reqError.region).toEqual('mock-region');
            return expect(resp.retryCount).toEqual(0);
          });
        });
      });
    }
  });

}).call(this);
