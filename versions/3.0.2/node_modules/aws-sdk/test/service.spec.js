(function() {
  var AWS, MockService, helpers;

  helpers = require('./helpers');

  AWS = helpers.AWS;

  MockService = helpers.MockService;

  describe('AWS.Service', function() {
    var config, retryableError, service;
    config = null;
    service = null;
    retryableError = function(error, result) {
      return expect(service.retryableError(error)).toEqual(result);
    };
    beforeEach(function() {
      config = new AWS.Config();
      return service = new AWS.Service(config);
    });
    describe('apiVersions', function() {
      return it('should set apiVersions property', function() {
        var CustomService;
        CustomService = AWS.Service.defineService('custom', ['2001-01-01', '1999-05-05']);
        return expect(CustomService.apiVersions).toEqual(['1999-05-05', '2001-01-01']);
      });
    });
    describe('constructor', function() {
      it('should use AWS.config copy if no config is provided', function() {
        service = new AWS.Service();
        expect(service.config).not.toBe(AWS.config);
        return expect(service.config.sslEnabled).toEqual(true);
      });
      it('should merge custom options on top of global defaults if config provided', function() {
        service = new AWS.Service({
          maxRetries: 5
        });
        expect(service.config.sslEnabled).toEqual(true);
        return expect(service.config.maxRetries).toEqual(5);
      });
      it('merges credential data into config', function() {
        service = new AWS.Service({
          accessKeyId: 'foo',
          secretAccessKey: 'bar'
        });
        expect(service.config.credentials.accessKeyId).toEqual('foo');
        return expect(service.config.credentials.secretAccessKey).toEqual('bar');
      });
      it('should allow AWS.config to be object literal', function() {
        var cfg;
        cfg = AWS.config;
        AWS.config = {
          maxRetries: 20
        };
        service = new AWS.Service({});
        expect(service.config.maxRetries).toEqual(20);
        expect(service.config.sslEnabled).toEqual(true);
        return AWS.config = cfg;
      });
      it('tries to construct service with latest API version', function() {
        var CustomService, errmsg;
        CustomService = AWS.Service.defineService('custom', ['2001-01-01', '1999-05-05']);
        errmsg = "Could not find API configuration custom-2001-01-01";
        return expect(function() {
          return new CustomService();
        }).toThrow(errmsg);
      });
      it('tries to construct service with exact API version match', function() {
        var CustomService, errmsg;
        CustomService = AWS.Service.defineService('custom', ['2001-01-01', '1999-05-05']);
        errmsg = "Could not find API configuration custom-1999-05-05";
        return expect(function() {
          return new CustomService({
            apiVersion: '1999-05-05'
          });
        }).toThrow(errmsg);
      });
      it('skips any API versions with a * and uses next (future) service', function() {
        var CustomService, errmsg;
        CustomService = AWS.Service.defineService('custom', ['1998-01-01', '1999-05-05*', '2001-01-01']);
        errmsg = "Could not find API configuration custom-2001-01-01";
        return expect(function() {
          return new CustomService({
            apiVersion: '2000-01-01'
          });
        }).toThrow(errmsg);
      });
      it('skips multiple API versions with a * and uses next (future) service', function() {
        var CustomService, errmsg;
        CustomService = AWS.Service.defineService('custom', ['1998-01-01', '1999-05-05*', '1999-07-07*', '2001-01-01']);
        errmsg = "Could not find API configuration custom-2001-01-01";
        return expect(function() {
          return new CustomService({
            apiVersion: '1999-05-05'
          });
        }).toThrow(errmsg);
      });
      it('tries to construct service with fuzzy API version match', function() {
        var CustomService, errmsg;
        CustomService = AWS.Service.defineService('custom', ['2001-01-01', '1999-05-05']);
        errmsg = "Could not find API configuration custom-1999-05-05";
        return expect(function() {
          return new CustomService({
            apiVersion: '2000-01-01'
          });
        }).toThrow(errmsg);
      });
      it('uses global apiVersion value when constructing versioned services', function() {
        var CustomService, errmsg;
        AWS.config.apiVersion = '2002-03-04';
        CustomService = AWS.Service.defineService('custom', ['2001-01-01', '1999-05-05']);
        errmsg = "Could not find API configuration custom-2001-01-01";
        expect(function() {
          return new CustomService;
        }).toThrow(errmsg);
        return AWS.config.apiVersion = null;
      });
      it('uses global apiVersions value when constructing versioned services', function() {
        var CustomService, errmsg;
        AWS.config.apiVersions = {
          custom: '2002-03-04'
        };
        CustomService = AWS.Service.defineService('custom', ['2001-01-01', '1999-05-05']);
        errmsg = "Could not find API configuration custom-2001-01-01";
        expect(function() {
          return new CustomService;
        }).toThrow(errmsg);
        return AWS.config.apiVersions = {};
      });
      it('uses service specific apiVersions before apiVersion', function() {
        var CustomService, errmsg;
        AWS.config.apiVersions = {
          custom: '2000-01-01'
        };
        AWS.config.apiVersion = '2002-03-04';
        CustomService = AWS.Service.defineService('custom', ['2001-01-01', '1999-05-05']);
        errmsg = "Could not find API configuration custom-1999-05-05";
        expect(function() {
          return new CustomService;
        }).toThrow(errmsg);
        AWS.config.apiVersion = null;
        return AWS.config.apiVersions = {};
      });
      it('tries to construct service with fuzzy API version match', function() {
        var CustomService, errmsg;
        CustomService = AWS.Service.defineService('custom', ['2001-01-01', '1999-05-05']);
        errmsg = "Could not find API configuration custom-1999-05-05";
        return expect(function() {
          return new CustomService({
            apiVersion: '2000-01-01'
          });
        }).toThrow(errmsg);
      });
      it('fails if apiVersion matches nothing', function() {
        var CustomService, errmsg;
        CustomService = AWS.Service.defineService('custom', ['2001-01-01', '1999-05-05']);
        errmsg = "Could not find custom API to satisfy version constraint `1998-01-01'";
        return expect(function() {
          return new CustomService({
            apiVersion: '1998-01-01'
          });
        }).toThrow(errmsg);
      });
      it('allows construction of services from one-off apiConfig properties', function() {
        service = new AWS.Service({
          apiConfig: {
            operations: {
              operationName: {
                input: {},
                output: {}
              }
            }
          }
        });
        expect(typeof service.operationName).toEqual('function');
        return expect(service.operationName() instanceof AWS.Request).toEqual(true);
      });
      return it('interpolates endpoint when reading from configuration', function() {
        service = new MockService({
          endpoint: '{scheme}://{service}.{region}.domain.tld'
        });
        expect(service.config.endpoint).toEqual('https://mockservice.mock-region.domain.tld');
        service = new MockService({
          sslEnabled: false,
          endpoint: '{scheme}://{service}.{region}.domain.tld'
        });
        return expect(service.config.endpoint).toEqual('http://mockservice.mock-region.domain.tld');
      });
    });
    describe('setEndpoint', function() {
      var FooService;
      FooService = null;
      beforeEach(function() {
        return FooService = AWS.util.inherit(AWS.Service, {
          api: {
            endpointPrefix: 'fooservice'
          }
        });
      });
      return it('uses specified endpoint if provided', function() {
        service = new FooService();
        service.setEndpoint('notfooservice.amazonaws.com');
        return expect(service.endpoint.host).toEqual('notfooservice.amazonaws.com');
      });
    });
    describe('makeRequest', function() {
      it('it treats params as an optinal parameter', function() {
        helpers.mockHttpResponse(200, {}, ['FOO', 'BAR']);
        service = new MockService();
        return service.makeRequest('operationName', function(err, data) {
          return expect(data).toEqual('FOOBAR');
        });
      });
      it('yields data to the callback', function() {
        var req;
        helpers.mockHttpResponse(200, {}, ['FOO', 'BAR']);
        service = new MockService();
        return req = service.makeRequest('operation', function(err, data) {
          expect(err).toEqual(null);
          return expect(data).toEqual('FOOBAR');
        });
      });
      it('yields service errors to the callback', function() {
        var req;
        helpers.mockHttpResponse(500, {}, ['ServiceError']);
        service = new MockService({
          maxRetries: 0
        });
        return req = service.makeRequest('operation', {}, function(err, data) {
          expect(err.code).toEqual('ServiceError');
          expect(err.message).toEqual(null);
          expect(err.statusCode).toEqual(500);
          expect(err.retryable).toEqual(true);
          return expect(data).toEqual(null);
        });
      });
      it('yields network errors to the callback', function() {
        var error, req;
        error = {
          code: 'NetworkingError'
        };
        helpers.mockHttpResponse(error);
        service = new MockService({
          maxRetries: 0
        });
        return req = service.makeRequest('operation', {}, function(err, data) {
          expect(err).toEqual(error);
          return expect(data).toEqual(null);
        });
      });
      it('does not send the request if a callback function is omitted', function() {
        var httpClient;
        helpers.mockHttpResponse(200, {}, ['FOO', 'BAR']);
        httpClient = AWS.HttpClient.getInstance();
        spyOn(httpClient, 'handleRequest');
        new MockService().makeRequest('operation');
        return expect(httpClient.handleRequest).not.toHaveBeenCalled();
      });
      it('allows parameter validation to be disabled in config', function() {
        var req;
        helpers.mockHttpResponse(200, {}, ['FOO', 'BAR']);
        service = new MockService({
          paramValidation: false
        });
        return req = service.makeRequest('operation', {}, function(err, data) {
          expect(err).toEqual(null);
          return expect(data).toEqual('FOOBAR');
        });
      });
      describe('bound parameters', function() {
        it('accepts toplevel bound parameters on the service', function() {
          var req;
          service = new AWS.S3({
            params: {
              Bucket: 'bucket',
              Key: 'key'
            }
          });
          req = service.makeRequest('getObject');
          return expect(req.params).toEqual({
            Bucket: 'bucket',
            Key: 'key'
          });
        });
        it('ignores bound parameters not in input members', function() {
          var req;
          service = new AWS.S3({
            params: {
              Bucket: 'bucket',
              Key: 'key'
            }
          });
          req = service.makeRequest('listObjects');
          return expect(req.params).toEqual({
            Bucket: 'bucket'
          });
        });
        return it('can override bound parameters', function() {
          var params, req;
          service = new AWS.S3({
            params: {
              Bucket: 'bucket',
              Key: 'key'
            }
          });
          params = {
            Bucket: 'notBucket'
          };
          req = service.makeRequest('listObjects', params);
          expect(params).not.toBe(req.params);
          return expect(req.params).toEqual({
            Bucket: 'notBucket'
          });
        });
      });
      return describe('global events', function() {
        return it('adds AWS.events listeners to requests', function() {
          var event;
          helpers.mockHttpResponse(200, {}, ['FOO', 'BAR']);
          event = jasmine.createSpy();
          AWS.events.on('complete', event);
          new MockService().makeRequest('operation').send();
          return expect(event).toHaveBeenCalled();
        });
      });
    });
    describe('retryableError', function() {
      it('should retry on throttle error', function() {
        return retryableError({
          code: 'ProvisionedThroughputExceededException',
          statusCode: 400
        }, true);
      });
      it('should retry on expired credentials error', function() {
        return retryableError({
          code: 'ExpiredTokenException',
          statusCode: 400
        }, true);
      });
      it('should retry on 500 or above regardless of error', function() {
        retryableError({
          code: 'Error',
          statusCode: 500
        }, true);
        return retryableError({
          code: 'RandomError',
          statusCode: 505
        }, true);
      });
      return it('should not retry when error is < 500 level status code', function() {
        retryableError({
          code: 'Error',
          statusCode: 200
        }, false);
        retryableError({
          code: 'Error',
          statusCode: 302
        }, false);
        return retryableError({
          code: 'Error',
          statusCode: 404
        }, false);
      });
    });
    return describe('numRetries', function() {
      it('should use config max retry value if defined', function() {
        service.config.maxRetries = 30;
        return expect(service.numRetries()).toEqual(30);
      });
      return it('should use defaultRetries defined on object if undefined on config', function() {
        service.defaultRetryCount = 13;
        service.config.maxRetries = void 0;
        return expect(service.numRetries()).toEqual(13);
      });
    });
  });

}).call(this);
