(function() {
  var AWS, Buffer, Operation, helpers, svc;

  helpers = require('../helpers');

  AWS = helpers.AWS;

  Operation = AWS.Model.Operation;

  Buffer = helpers.util.Buffer;

  svc = AWS.Protocol.RestJson;

  describe('AWS.Protocol.RestJson', function() {
    var MockJSONRESTService, defop, operation, request, response, service;
    MockJSONRESTService = helpers.util.inherit(AWS.Service, {
      endpointPrefix: 'mockservice'
    });
    operation = null;
    request = null;
    response = null;
    service = null;
    beforeEach(function() {
      MockJSONRESTService.prototype.api = new AWS.Model.Api({
        operations: {
          sampleOperation: {
            http: {
              method: 'POST',
              uri: '/'
            },
            input: {
              type: 'structure',
              members: {}
            },
            output: {
              type: 'structure',
              members: {
                a: {
                  type: 'string'
                },
                b: {
                  type: 'string'
                }
              }
            }
          }
        }
      });
      AWS.Service.defineMethods(MockJSONRESTService);
      operation = MockJSONRESTService.prototype.api.operations.sampleOperation;
      service = new MockJSONRESTService({
        region: 'region'
      });
      request = new AWS.Request(service, 'sampleOperation');
      return response = new AWS.Response(request);
    });
    defop = function(op) {
      return helpers.util.property(service.api.operations, 'sampleOperation', new Operation('sampleOperation', op, {
        api: service.api
      }));
    };
    describe('buildRequest', function() {
      var build;
      build = function() {
        svc.buildRequest(request);
        return request;
      };
      describe('method', function() {
        return it('populates method from the operation', function() {
          defop({
            http: {
              method: 'GET'
            }
          });
          return expect(build().httpRequest.method).toEqual('GET');
        });
      });
      describe('uri', function() {
        it('populates uri from the operation', function() {
          defop({
            http: {
              requestUri: '/path'
            }
          });
          return expect(build().httpRequest.path).toEqual('/path');
        });
        it('replaces param placeholders', function() {
          request.params = {
            Id: 'abc'
          };
          defop({
            http: {
              requestUri: '/Owner/{Id}'
            },
            input: {
              type: 'structure',
              members: {
                Id: {
                  location: 'uri'
                }
              }
            }
          });
          return expect(build().httpRequest.path).toEqual('/Owner/abc');
        });
        it('can replace multiple path placeholders', function() {
          request.params = {
            Id: 'abc',
            Count: 123
          };
          defop({
            http: {
              requestUri: '/{Id}/{Count}'
            },
            input: {
              type: 'structure',
              members: {
                Id: {
                  location: 'uri',
                  type: 'string'
                },
                Count: {
                  type: 'integer',
                  location: 'uri'
                }
              }
            }
          });
          return expect(build().httpRequest.path).toEqual('/abc/123');
        });
        return it('performs querystring param replacements', function() {
          request.params = {
            Id: 'abc'
          };
          defop({
            http: {
              requestUri: '/path'
            },
            input: {
              type: 'structure',
              members: {
                Id: {
                  location: 'querystring',
                  locationName: 'id-param'
                }
              }
            }
          });
          return expect(build().httpRequest.path).toEqual('/path?id-param=abc');
        });
      });
      describe('headers', function() {
        it('populates the headers with present params', function() {
          request.params = {
            ACL: 'public-read'
          };
          defop({
            input: {
              members: {
                ACL: {
                  location: 'header',
                  locationName: 'x-amz-acl'
                }
              }
            }
          });
          return expect(build().httpRequest.headers['x-amz-acl']).toEqual('public-read');
        });
        it('uses default rule name if .n property is not present', function() {
          request.params = {
            ACL: 'public-read'
          };
          defop({
            input: {
              members: {
                ACL: {
                  location: 'header'
                }
              }
            }
          });
          return expect(build().httpRequest.headers['ACL']).toEqual('public-read');
        });
        return it('works with map types', function() {
          request.params = {
            Metadata: {
              foo: 'bar',
              abc: 'xyz'
            }
          };
          defop({
            input: {
              members: {
                Metadata: {
                  type: 'map',
                  location: 'headers',
                  locationName: 'x-amz-meta-'
                }
              }
            }
          });
          build();
          expect(request.httpRequest.headers['x-amz-meta-foo']).toEqual('bar');
          return expect(request.httpRequest.headers['x-amz-meta-abc']).toEqual('xyz');
        });
      });
      return describe('body', function() {
        it('builds root element if rules contains root', function() {
          request.params = {
            Config: {
              Name: 'foo',
              Type: 'bar'
            }
          };
          defop({
            input: {
              payload: 'Config',
              members: {
                Config: {
                  type: 'structure',
                  members: {
                    Name: {
                      type: 'string'
                    },
                    Type: {
                      type: 'string'
                    }
                  }
                }
              }
            }
          });
          return expect(build().httpRequest.body.toString()).toEqual('{"Name":"foo","Type":"bar"}');
        });
        return it('builds payload element as non JSON data if rules contains payload', function() {
          request.params = {
            Body: 'foobar'
          };
          defop({
            input: {
              payload: 'Body',
              members: {
                Body: {
                  type: 'binary'
                }
              }
            }
          });
          return expect(build().httpRequest.body).toEqual('foobar');
        });
      });
    });
    describe('extractError', function() {
      var extractError;
      extractError = function(body) {
        response.httpResponse.statusCode = 500;
        response.httpResponse.body = new Buffer(body);
        return svc.extractError(response);
      };
      it('removes prefixes from the error code', function() {
        extractError('{"__type":"com.amazon.coral.service#ErrorCode" }');
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.code).toEqual('ErrorCode');
        return expect(response.data).toEqual(null);
      });
      it('returns the full code when a # is not present', function() {
        extractError('{"__type":"ErrorCode" }');
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.code).toEqual('ErrorCode');
        return expect(response.data).toEqual(null);
      });
      it('returns the status code when the body is blank', function() {
        extractError('');
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.code).toEqual(500);
        expect(response.error.message).toEqual(null);
        return expect(response.data).toEqual(null);
      });
      it('returns null for the message when not present', function() {
        extractError('{"__type":"ErrorCode" }');
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.message).toEqual(null);
        return expect(response.data).toEqual(null);
      });
      it('returns the message when present', function() {
        extractError('{"__type":"ErrorCode", "message":"Error Message" }');
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.message).toEqual('Error Message');
        return expect(response.data).toEqual(null);
      });
      it('returns the message when the message property is upper-cased', function() {
        extractError('{"__type":"ErrorCode", "Message":"Error Message" }');
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.message).toEqual('Error Message');
        return expect(response.data).toEqual(null);
      });
      return it('returns a special message for RequestEntityToLarge errors', function() {
        extractError('{"__type":"RequestEntityTooLarge" }');
        expect(response.error instanceof Error).toBeTruthy();
        expect(response.error.message).toEqual('Request body must be less than 1 MB');
        return expect(response.data).toEqual(null);
      });
    });
    return describe('extractData', function() {
      var extractData;
      extractData = function(body) {
        response.httpResponse.statusCode = 200;
        response.httpResponse.body = new Buffer(body);
        return svc.extractData(response);
      };
      it('JSON parses http response bodies', function() {
        extractData('{"a":1, "b":"xyz"}');
        expect(response.error).toEqual(null);
        return expect(response.data).toEqual({
          a: 1,
          b: 'xyz'
        });
      });
      it('pulls header data out of response', function() {
        response.httpResponse.headers['x-title'] = 'The title';
        defop({
          output: {
            type: 'structure',
            members: {
              Title: {
                location: 'header',
                locationName: 'x-title'
              }
            }
          }
        });
        extractData('{}');
        expect(response.error).toEqual(null);
        return expect(response.data.Title).toEqual('The title');
      });
      it('pulls body out into data key if body is payload', function() {
        defop({
          output: {
            type: 'structure',
            payload: 'Body',
            members: {
              Body: {
                location: 'body',
                type: 'binary'
              }
            }
          }
        });
        extractData('foobar');
        expect(response.error).toEqual(null);
        return expect(response.data.Body).toEqual('foobar');
      });
      it('pulls body out as Buffer if body is streaming payload', function() {
        defop({
          output: {
            type: 'structure',
            payload: 'Body',
            members: {
              Body: {
                location: 'body',
                type: 'binary',
                streaming: true
              }
            }
          }
        });
        extractData('foobar');
        expect(response.error).toEqual(null);
        expect(Buffer.isBuffer(response.data.Body)).toEqual(true);
        return expect(response.data.Body.toString()).toEqual('foobar');
      });
      it('returns an empty object when the body is an empty string', function() {
        extractData('');
        expect(response.error).toEqual(null);
        return expect(response.data).toEqual({});
      });
      return it('returns an empty object when the body is null', function() {
        extractData('');
        expect(response.error).toEqual(null);
        return expect(response.data).toEqual({});
      });
    });
  });

}).call(this);
