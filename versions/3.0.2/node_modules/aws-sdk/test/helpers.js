(function() {
  var AWS, Buffer, EventEmitter, MockService, flattenXML, ignoreRequire, matchXML, mockHttpResponse, mockHttpSuccessfulResponse, mockIntermittentFailureResponse, mockResponse, mockResponses, semver;

  AWS = null;

  ignoreRequire = require;

  if (typeof window === 'undefined') {
    AWS = ignoreRequire('../lib/aws');
  } else {
    AWS = window.AWS;
  }

  EventEmitter = require('events').EventEmitter;

  Buffer = AWS.util.Buffer;

  semver = require('semver');

  require('util').print = function(data) {
    return process.stdout.write(data);
  };

  AWS.config.update({
    paramValidation: false,
    region: 'mock-region',
    credentials: {
      accessKeyId: 'akid',
      secretAccessKey: 'secret',
      sessionToken: 'session'
    }
  });

  setTimeout = function(fn, delay) { fn(); };

  flattenXML = function(xml) {
    if (!xml) {
      return xml;
    }
    return xml.split("\n").join('').replace(/>\s+</g, '><').replace(/^\s+|\s+$/g, '');
  };

  matchXML = function(xml1, xml2) {
    return expect(flattenXML(xml1)).toEqual(flattenXML(xml2));
  };

  MockService = AWS.Service.defineService('mockService', {
    serviceIdentifier: 'mock',
    initialize: function(config) {
      AWS.Service.prototype.initialize.call(this, config);
      this.config.credentials = {
        accessKeyId: 'akid',
        secretAccessKey: 'secret'
      };
      return this.config.region = 'mock-region';
    },
    setupRequestListeners: function(request) {
      request.on('extractData', function(resp) {
        return resp.data = resp.httpResponse.body.toString();
      });
      return request.on('extractError', function(resp) {
        return resp.error = {
          code: resp.httpResponse.body.toString() || resp.httpResponse.statusCode,
          message: null
        };
      });
    },
    api: new AWS.Model.Api({
      metadata: {
        endpointPrefix: 'mockservice',
        signatureVersion: 'v4'
      }
    })
  });

  mockHttpSuccessfulResponse = function(status, headers, data, cb) {
    var httpResp;
    if (!Array.isArray(data)) {
      data = [data];
    }
    httpResp = new EventEmitter();
    httpResp.statusCode = status;
    httpResp.headers = headers;
    cb(httpResp);
    httpResp.emit('headers', status, headers);
    if (AWS.util.isNode() && httpResp._events.readable) {
      httpResp.read = function() {
        var chunk;
        if (data.length > 0) {
          chunk = data.shift();
          if (chunk === null) {
            return null;
          } else {
            return new Buffer(chunk);
          }
        } else {
          return null;
        }
      };
    }
    AWS.util.arrayEach(data.slice(), function(str) {
      if (AWS.util.isNode() && (httpResp._events.readable || semver.gt(process.version, 'v0.11.3'))) {
        return httpResp.emit('readable');
      } else {
        return httpResp.emit('data', new Buffer(str));
      }
    });
    if (httpResp._events['readable'] || httpResp._events['data']) {
      return httpResp.emit('end');
    } else {
      return httpResp.emit('aborted');
    }
  };

  mockHttpResponse = function(status, headers, data) {
    var stream;
    stream = new EventEmitter();
    stream.setMaxListeners(0);
    spyOn(AWS.HttpClient, 'getInstance');
    AWS.HttpClient.getInstance.andReturn({
      handleRequest: function(req, opts, cb, errCb) {
        if (typeof status === 'number') {
          mockHttpSuccessfulResponse(status, headers, data, cb);
        } else {
          errCb(status);
        }
        return stream;
      }
    });
    return stream;
  };

  mockIntermittentFailureResponse = function(numFailures, status, headers, data) {
    var retryCount;
    retryCount = 0;
    spyOn(AWS.HttpClient, 'getInstance');
    return AWS.HttpClient.getInstance.andReturn({
      handleRequest: function(req, opts, cb, errCb) {
        var ref, statusCode;
        if (retryCount < numFailures) {
          retryCount += 1;
          errCb({
            code: 'NetworkingError',
            message: 'FAIL!'
          });
        } else {
          statusCode = (ref = retryCount < numFailures) != null ? ref : {
            500: status
          };
          mockHttpSuccessfulResponse(statusCode, headers, data, cb);
        }
        return new EventEmitter();
      }
    });
  };

  mockResponse = function(svc, resp) {
    var addAll;
    addAll = svc.addAllRequestListeners;
    return spyOn(svc, 'addAllRequestListeners').andCallFake(function(req) {
      req.response.httpResponse.statusCode = 200;
      addAll.call(svc, req);
      req.removeAllListeners('send');
      req.removeAllListeners('extractError');
      req.removeAllListeners('extractData');
      return req.on('validateResponse', function() {
        return AWS.util.update(req.response, resp);
      });
    });
  };

  mockResponses = function(svc, resps) {
    var addAll, index;
    index = 0;
    addAll = svc.addAllRequestListeners;
    return spyOn(svc, 'addAllRequestListeners').andCallFake(function(req) {
      req.response.httpResponse.statusCode = 200;
      addAll.call(svc, req);
      req.removeAllListeners('send');
      req.removeAllListeners('extractError');
      req.removeAllListeners('extractData');
      return req.on('validateResponse', function() {
        var resp;
        resp = resps[index];
        if (resp) {
          AWS.util.update(req.response, resp);
          return index += 1;
        }
      });
    });
  };

  module.exports = {
    AWS: AWS,
    util: AWS.util,
    matchXML: matchXML,
    mockHttpResponse: mockHttpResponse,
    mockIntermittentFailureResponse: mockIntermittentFailureResponse,
    mockHttpSuccessfulResponse: mockHttpSuccessfulResponse,
    mockResponse: mockResponse,
    mockResponses: mockResponses,
    MockService: MockService
  };

}).call(this);
