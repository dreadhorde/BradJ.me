(function() {
  var AWS, buildRequest, buildSigner, helpers;

  helpers = require('../helpers');

  AWS = helpers.AWS;

  beforeEach(function() {
    return spyOn(AWS.util, 'userAgent').andReturn('aws-sdk-js/0.1');
  });

  buildRequest = function() {
    var ddb, req;
    ddb = new AWS.DynamoDB({
      region: 'region',
      endpoint: 'localhost',
      apiVersion: '2011-12-05'
    });
    req = ddb.makeRequest('listTables', {
      ExclusiveStartTableName: 'b√•r'
    });
    req.build();
    req.httpRequest.headers['X-Amz-User-Agent'] = 'aws-sdk-js/0.1';
    return req.httpRequest;
  };

  buildSigner = function(request) {
    return new AWS.Signers.V4(request || buildRequest(), 'dynamodb');
  };

  describe('AWS.Signers.V4', function() {
    var authorization, creds, date, datetime, signature, signer;
    date = new Date(1935346573456);
    datetime = AWS.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, '');
    creds = null;
    signature = '0e24aaa0cc86cdc1b73143a147e731cf8c93d450cfcf1d18b2b7473f810b7a1d';
    authorization = 'AWS4-HMAC-SHA256 Credential=akid/20310430/region/dynamodb/aws4_request, ' + 'SignedHeaders=host;x-amz-date;x-amz-security-token;x-amz-target;x-amz-user-agent, ' + 'Signature=' + signature;
    signer = null;
    beforeEach(function() {
      creds = {
        accessKeyId: 'akid',
        secretAccessKey: 'secret',
        sessionToken: 'session'
      };
      signer = buildSigner();
      return signer.addHeaders(creds, datetime);
    });
    describe('constructor', function() {
      return it('can build a signer for a request object', function() {
        var req;
        req = buildRequest();
        signer = buildSigner(req);
        return expect(signer.request).toBe(req);
      });
    });
    describe('addAuthorization', function() {
      var headers, key, results, value;
      headers = {
        'Content-Type': 'application/x-amz-json-1.0',
        'Content-Length': 34,
        'X-Amz-Target': 'DynamoDB_20111205.ListTables',
        'Host': 'localhost',
        'X-Amz-Date': datetime,
        'x-amz-security-token': 'session',
        'Authorization': authorization
      };
      results = [];
      for (key in headers) {
        value = headers[key];
        results.push(it('should add ' + key + ' header', function() {
          signer.addAuthorization(creds, date);
          key = this.description.match(/(\S+) header/)[1];
          return expect(signer.request.headers[key]).toEqual(headers[key]);
        }));
      }
      return results;
    });
    describe('authorization', function() {
      return it('should return authorization part for signer', function() {
        return expect(signer.authorization(creds, datetime)).toEqual(authorization);
      });
    });
    describe('signature', function() {
      it('should generate proper signature', function() {
        return expect(signer.signature(creds, datetime)).toEqual(signature);
      });
      return describe('caching', function() {
        var callCount, calls;
        callCount = null;
        calls = null;
        beforeEach(function() {
          spyOn(AWS.util.crypto, 'hmac');
          signer.signature(creds, datetime);
          calls = AWS.util.crypto.hmac.calls;
          return callCount = calls.length;
        });
        it('caches subsequent requests', function() {
          signer.signature(creds, datetime);
          expect(calls.length).toEqual(callCount + 1);
          signer.signature(creds, datetime);
          return expect(calls.length).toEqual(callCount + 2);
        });
        it('busts cache if region changes', function() {
          signer.request.region = 'new-region';
          signer.signature(creds, datetime);
          return expect(calls.length).toEqual(callCount + 5);
        });
        it('busts cache if service changes', function() {
          signer.serviceName = 'newService';
          signer.signature(creds, datetime);
          return expect(calls.length).toEqual(callCount + 5);
        });
        it('busts cache if access key changes', function() {
          creds.accessKeyId = 'NEWAKID';
          signer.signature(creds, datetime);
          return expect(calls.length).toEqual(callCount + 5);
        });
        return it('busts cache if date changes', function() {
          var newDate, newDatetime;
          newDate = new Date(date.getTime() + 1000000000);
          newDatetime = AWS.util.date.iso8601(newDate).replace(/[:\-]|\.\d{3}/g, '');
          signer.signature(creds, newDatetime);
          return expect(calls.length).toEqual(callCount + 5);
        });
      });
    });
    describe('stringToSign', function() {
      return it('should sign correctly generated input string', function() {
        return expect(signer.stringToSign(datetime)).toEqual('AWS4-HMAC-SHA256\n' + datetime + '\n' + '20310430/region/dynamodb/aws4_request\n' + signer.hexEncodedHash(signer.canonicalString()));
      });
    });
    return describe('canonicalHeaders', function() {
      it('should return headers', function() {
        return expect(signer.canonicalHeaders()).toEqual(['host:localhost', 'x-amz-date:' + datetime, 'x-amz-security-token:session', 'x-amz-target:DynamoDB_20111205.ListTables', 'x-amz-user-agent:aws-sdk-js/0.1'].join('\n'));
      });
      it('should ignore Authorization header', function() {
        signer.request.headers = {
          'Authorization': 'foo'
        };
        return expect(signer.canonicalHeaders()).toEqual('');
      });
      it('should lowercase all header names (not values)', function() {
        signer.request.headers = {
          'FOO': 'BAR'
        };
        return expect(signer.canonicalHeaders()).toEqual('foo:BAR');
      });
      it('should sort headers by key', function() {
        signer.request.headers = {
          abc: 'a',
          bca: 'b',
          Qux: 'c',
          bar: 'd'
        };
        return expect(signer.canonicalHeaders()).toEqual('abc:a\nbar:d\nbca:b\nqux:c');
      });
      it('should compact multiple spaces in keys/values to a single space', function() {
        signer.request.headers = {
          'Header': 'Value     with  Multiple   \t spaces'
        };
        return expect(signer.canonicalHeaders()).toEqual('header:Value with Multiple spaces');
      });
      return it('should strip starting and end of line spaces', function() {
        signer.request.headers = {
          'Header': ' \t   Value  \t  '
        };
        return expect(signer.canonicalHeaders()).toEqual('header:Value');
      });
    });
  });

}).call(this);
