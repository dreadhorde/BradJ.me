(function() {
  var AWS, helpers, validateCredentials;

  helpers = require('./helpers');

  AWS = helpers.AWS;

  validateCredentials = function(creds, key, secret, session) {
    expect(creds.accessKeyId).toEqual(key || 'akid');
    expect(creds.secretAccessKey).toEqual(secret || 'secret');
    return expect(creds.sessionToken).toEqual(session || 'session');
  };

  describe('AWS.Credentials', function() {
    describe('constructor', function() {
      it('should allow setting of credentials with keys', function() {
        var config;
        config = new AWS.Config({
          accessKeyId: 'akid',
          secretAccessKey: 'secret',
          sessionToken: 'session'
        });
        return validateCredentials(config.credentials);
      });
      it('should allow setting of credentials as object', function() {
        var creds;
        creds = {
          accessKeyId: 'akid',
          secretAccessKey: 'secret',
          sessionToken: 'session'
        };
        return validateCredentials(new AWS.Credentials(creds));
      });
      return it('defaults credentials to undefined when not passed', function() {
        var creds;
        creds = new AWS.Credentials();
        expect(creds.accessKeyId).toBe(void 0);
        expect(creds.secretAccessKey).toBe(void 0);
        return expect(creds.sessionToken).toBe(void 0);
      });
    });
    describe('needsRefresh', function() {
      it('needs refresh if credentials are not set', function() {
        var creds;
        creds = new AWS.Credentials();
        expect(creds.needsRefresh()).toEqual(true);
        creds = new AWS.Credentials('akid');
        return expect(creds.needsRefresh()).toEqual(true);
      });
      it('does not need refresh if credentials are set', function() {
        var creds;
        creds = new AWS.Credentials('akid', 'secret');
        return expect(creds.needsRefresh()).toEqual(false);
      });
      it('needs refresh if creds are expired', function() {
        var creds;
        creds = new AWS.Credentials('akid', 'secret');
        creds.expired = true;
        return expect(creds.needsRefresh()).toEqual(true);
      });
      it('can be expired based on expireTime', function() {
        var creds;
        creds = new AWS.Credentials('akid', 'secret');
        creds.expired = false;
        creds.expireTime = new Date(0);
        return expect(creds.needsRefresh()).toEqual(true);
      });
      it('needs refresh if expireTime is within expiryWindow secs from now', function() {
        var creds;
        creds = new AWS.Credentials('akid', 'secret');
        creds.expired = false;
        creds.expireTime = new Date(AWS.util.date.getDate().getTime() + 1000);
        return expect(creds.needsRefresh()).toEqual(true);
      });
      return it('does not need refresh if expireTime outside expiryWindow', function() {
        var creds, ms;
        creds = new AWS.Credentials('akid', 'secret');
        creds.expired = false;
        ms = AWS.util.date.getDate().getTime() + (creds.expiryWindow + 5) * 1000;
        creds.expireTime = new Date(ms);
        return expect(creds.needsRefresh()).toEqual(false);
      });
    });
    return describe('get', function() {
      it('does not call refresh if not needsRefresh', function() {
        var creds, refresh, spy;
        spy = jasmine.createSpy('done callback');
        creds = new AWS.Credentials('akid', 'secret');
        refresh = spyOn(creds, 'refresh');
        creds.get(spy);
        expect(refresh).not.toHaveBeenCalled();
        expect(spy).toHaveBeenCalled();
        expect(spy.argsForCall[0][0]).toEqual(null);
        return expect(creds.expired).toEqual(false);
      });
      return it('calls refresh only if needsRefresh', function() {
        var creds, refresh, spy;
        spy = jasmine.createSpy('done callback');
        creds = new AWS.Credentials('akid', 'secret');
        creds.expired = true;
        refresh = spyOn(creds, 'refresh').andCallThrough();
        creds.get(spy);
        expect(refresh).toHaveBeenCalled();
        expect(spy).toHaveBeenCalled();
        expect(spy.argsForCall[0][0]).toEqual(null);
        return expect(creds.expired).toEqual(false);
      });
    });
  });

  if (AWS.util.isNode()) {
    describe('AWS.EnvironmentCredentials', function() {
      beforeEach(function() {
        return process.env = {};
      });
      describe('constructor', function() {
        it('should be able to read credentials from env with a prefix', function() {
          var creds;
          process.env.AWS_ACCESS_KEY_ID = 'akid';
          process.env.AWS_SECRET_ACCESS_KEY = 'secret';
          process.env.AWS_SESSION_TOKEN = 'session';
          creds = new AWS.EnvironmentCredentials('AWS');
          return validateCredentials(creds);
        });
        return it('should be able to read credentials from env without a prefix', function() {
          var creds;
          process.env.ACCESS_KEY_ID = 'akid';
          process.env.SECRET_ACCESS_KEY = 'secret';
          process.env.SESSION_TOKEN = 'session';
          creds = new AWS.EnvironmentCredentials();
          return validateCredentials(creds);
        });
      });
      return describe('refresh', function() {
        return it('can refresh credentials', function() {
          var creds;
          process.env.AWS_ACCESS_KEY_ID = 'akid';
          process.env.AWS_SECRET_ACCESS_KEY = 'secret';
          creds = new AWS.EnvironmentCredentials('AWS');
          expect(creds.accessKeyId).toEqual('akid');
          creds.accessKeyId = 'not_akid';
          expect(creds.accessKeyId).not.toEqual('akid');
          creds.refresh();
          return expect(creds.accessKeyId).toEqual('akid');
        });
      });
    });
    describe('AWS.FileSystemCredentials', function() {
      describe('constructor', function() {
        it('should accept filename and load credentials from root doc', function() {
          var creds, mock;
          mock = '{"accessKeyId":"akid", "secretAccessKey":"secret","sessionToken":"session"}';
          spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.FileSystemCredentials('foo');
          return validateCredentials(creds);
        });
        return it('should accept filename and load credentials from credentials block', function() {
          var creds, mock, spy;
          mock = '{"credentials":{"accessKeyId":"akid", "secretAccessKey":"secret","sessionToken":"session"}}';
          spy = spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.FileSystemCredentials('foo');
          return validateCredentials(creds);
        });
      });
      return describe('refresh', function() {
        it('should refresh from given filename', function() {
          var creds, mock;
          mock = '{"credentials":{"accessKeyId":"RELOADED", "secretAccessKey":"RELOADED","sessionToken":"RELOADED"}}';
          spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.FileSystemCredentials('foo');
          return validateCredentials(creds, 'RELOADED', 'RELOADED', 'RELOADED');
        });
        return it('fails if credentials are not in the file', function() {
          var mock;
          mock = '{"credentials":{}}';
          spyOn(AWS.util, 'readFileSync').andReturn(mock);
          new AWS.FileSystemCredentials('foo').refresh(function(err) {
            return expect(err.message).toEqual('Credentials not set in foo');
          });
          return expect(function() {
            return new AWS.FileSystemCredentials('foo').refresh();
          }).toThrow('Credentials not set in foo');
        });
      });
    });
    describe('AWS.SharedIniFileCredentials', function() {
      beforeEach(function() {
        delete process.env.AWS_PROFILE;
        delete process.env.HOME;
        delete process.env.HOMEPATH;
        return delete process.env.USERPROFILE;
      });
      describe('constructor', function() {
        it('throws an error if HOME/HOMEPATH/USERPROFILE are not set', function() {
          return expect(function() {
            return new AWS.SharedIniFileCredentials().refresh();
          }).toThrow('Cannot load credentials, HOME path not set');
        });
        it('uses HOMEPATH if HOME is not set', function() {
          var creds;
          process.env.HOMEPATH = '/homepath';
          creds = new AWS.SharedIniFileCredentials();
          return expect(creds.filename).toEqual('/homepath/.aws/credentials');
        });
        it('uses USERPROFILE if HOME and HOMEPATH are not set', function() {
          var creds;
          process.env.USERPROFILE = '/userprofile';
          creds = new AWS.SharedIniFileCredentials();
          return expect(creds.filename).toEqual('/userprofile/.aws/credentials');
        });
        return it('can override filename as a constructor argument', function() {
          var creds;
          creds = new AWS.SharedIniFileCredentials({
            filename: '/etc/creds'
          });
          return expect(creds.filename).toEqual('/etc/creds');
        });
      });
      describe('loading', function() {
        beforeEach(function() {
          return process.env.HOME = '/home/user';
        });
        it('loads credentials from ~/.aws/credentials using default profile', function() {
          var creds, mock;
          mock = '[default]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
          spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.SharedIniFileCredentials();
          validateCredentials(creds);
          return expect(AWS.util.readFileSync.calls[0].args[0]).toEqual('/home/user/.aws/credentials');
        });
        it('loads the default profile if AWS_PROFILE is empty', function() {
          var creds, mock;
          process.env.AWS_PROFILE = '';
          mock = '[default]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
          spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.SharedIniFileCredentials();
          return validateCredentials(creds);
        });
        it('accepts a profile name parameter', function() {
          var creds, mock, spy;
          mock = '[foo]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
          spy = spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.SharedIniFileCredentials({
            profile: 'foo'
          });
          return validateCredentials(creds);
        });
        return it('sets profile based on ENV', function() {
          var creds, mock, spy;
          process.env.AWS_PROFILE = 'foo';
          mock = '[foo]\naws_access_key_id = akid\naws_secret_access_key = secret\naws_session_token = session';
          spy = spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.SharedIniFileCredentials();
          return validateCredentials(creds);
        });
      });
      return describe('refresh', function() {
        beforeEach(function() {
          return process.env.HOME = '/home/user';
        });
        it('should refresh from disk', function() {
          var creds, mock;
          mock = '[default]\naws_access_key_id = RELOADED\naws_secret_access_key = RELOADED\naws_session_token = RELOADED';
          spyOn(AWS.util, 'readFileSync').andReturn(mock);
          creds = new AWS.SharedIniFileCredentials();
          return validateCredentials(creds, 'RELOADED', 'RELOADED', 'RELOADED');
        });
        return it('fails if credentials are not in the file', function() {
          var mock;
          mock = '';
          spyOn(AWS.util, 'readFileSync').andReturn(mock);
          new AWS.SharedIniFileCredentials().refresh(function(err) {
            return expect(err.message).toEqual('Credentials not set in /home/user/.aws/credentials using profile default');
          });
          return expect(function() {
            return new AWS.SharedIniFileCredentials().refresh();
          }).toThrow('Credentials not set in /home/user/.aws/credentials using profile default');
        });
      });
    });
    describe('AWS.EC2MetadataCredentials', function() {
      var creds, mockMetadataService;
      creds = null;
      beforeEach(function() {
        return creds = new AWS.EC2MetadataCredentials({
          host: 'host'
        });
      });
      mockMetadataService = function(expireTime) {
        return spyOn(creds.metadataService, 'loadCredentials').andCallFake(function(cb) {
          return cb(null, {
            Code: 'Success',
            AccessKeyId: 'KEY',
            SecretAccessKey: 'SECRET',
            Token: 'TOKEN',
            Expiration: expireTime.toISOString()
          });
        });
      };
      describe('constructor', function() {
        return it('allows passing of AWS.MetadataService options', function() {
          return expect(creds.metadataService.host).toEqual('host');
        });
      });
      describe('needsRefresh', function() {
        return it('can be expired based on expire time from EC2 Metadata service', function() {
          mockMetadataService(new Date(0));
          creds.refresh(function() {});
          return expect(creds.needsRefresh()).toEqual(true);
        });
      });
      return describe('refresh', function() {
        it('loads credentials from EC2 Metadata service', function() {
          mockMetadataService(new Date(AWS.util.date.getDate().getTime() + 100000));
          creds.refresh(function() {});
          expect(creds.metadata.Code).toEqual('Success');
          expect(creds.accessKeyId).toEqual('KEY');
          expect(creds.secretAccessKey).toEqual('SECRET');
          expect(creds.sessionToken).toEqual('TOKEN');
          return expect(creds.needsRefresh()).toEqual(false);
        });
        return it('does try to load creds second time if Metadata service failed', function() {
          var spy;
          spy = spyOn(creds.metadataService, 'loadCredentials').andCallFake(function(cb) {
            return cb(new Error('INVALID SERVICE'));
          });
          creds.refresh(function(err) {
            return expect(err.message).toEqual('INVALID SERVICE');
          });
          return creds.refresh(function() {
            return creds.refresh(function() {
              return creds.refresh(function() {
                return expect(spy.calls.length).toEqual(4);
              });
            });
          });
        });
      });
    });
  }

  describe('AWS.TemporaryCredentials', function() {
    var creds, mockSTS;
    creds = null;
    beforeEach(function() {
      return creds = new AWS.TemporaryCredentials({
        DurationSeconds: 1200
      });
    });
    mockSTS = function(expireTime, inParams) {
      var operation;
      if (!inParams) {
        inParams = {
          DurationSeconds: 1200
        };
      }
      if (inParams.RoleArn) {
        operation = 'assumeRole';
      } else {
        operation = 'getSessionToken';
      }
      return spyOn(creds.service, operation).andCallFake(function(params, cb) {
        expect(params).toEqual(inParams);
        return cb(null, {
          Credentials: {
            AccessKeyId: 'KEY',
            SecretAccessKey: 'SECRET',
            SessionToken: 'TOKEN',
            Expiration: expireTime
          }
        });
      });
    };
    describe('masterCredentials', function() {
      it('seeds masterCredentials from global credentials', function() {
        var origCreds;
        origCreds = AWS.config.credentials;
        AWS.config.credentials = new AWS.Credentials('AKID', 'SECRET');
        creds = new AWS.TemporaryCredentials();
        expect(creds.masterCredentials.accessKeyId).toEqual('AKID');
        expect(creds.masterCredentials.secretAccessKey).toEqual('SECRET');
        return AWS.config.credentials = origCreds;
      });
      return it('seeds masterCredentials from temporary credentials', function() {
        var i, j, origCreds;
        origCreds = AWS.config.credentials;
        AWS.config.credentials = new AWS.Credentials('AKID', 'SECRET');
        for (i = j = 0; j <= 3; i = ++j) {
          creds = new AWS.TemporaryCredentials();
          expect(creds.masterCredentials.accessKeyId).toEqual('AKID');
          expect(creds.masterCredentials.secretAccessKey).toEqual('SECRET');
        }
        return AWS.config.credentials = origCreds;
      });
    });
    describe('needsRefresh', function() {
      return it('can be expired based on expire time from STS response', function() {
        mockSTS(new Date(0));
        creds.refresh(function() {});
        return expect(creds.needsRefresh()).toEqual(true);
      });
    });
    return describe('refresh', function() {
      it('loads temporary credentials from STS using getSessionToken', function() {
        mockSTS(new Date(AWS.util.date.getDate().getTime() + 100000));
        creds.refresh(function() {});
        expect(creds.accessKeyId).toEqual('KEY');
        expect(creds.secretAccessKey).toEqual('SECRET');
        expect(creds.sessionToken).toEqual('TOKEN');
        return expect(creds.needsRefresh()).toEqual(false);
      });
      it('loads temporary credentials from STS using assumeRole if RoleArn is provided', function() {
        creds = new AWS.TemporaryCredentials({
          RoleArn: 'ARN'
        });
        mockSTS(new Date(AWS.util.date.getDate().getTime() + 100000), {
          RoleArn: 'ARN',
          RoleSessionName: 'temporary-credentials'
        });
        creds.refresh(function() {});
        expect(creds.accessKeyId).toEqual('KEY');
        expect(creds.secretAccessKey).toEqual('SECRET');
        expect(creds.sessionToken).toEqual('TOKEN');
        return expect(creds.needsRefresh()).toEqual(false);
      });
      return it('does try to load creds second time if service request failed', function() {
        var spy;
        spy = spyOn(creds.service, 'getSessionToken').andCallFake(function(params, cb) {
          return cb(new Error('INVALID SERVICE'));
        });
        creds.refresh(function(err) {
          return expect(err.message).toEqual('INVALID SERVICE');
        });
        return creds.refresh(function() {
          return creds.refresh(function() {
            return creds.refresh(function() {
              return expect(spy.calls.length).toEqual(4);
            });
          });
        });
      });
    });
  });

  describe('AWS.WebIdentityCredentials', function() {
    var creds, mockSTS;
    creds = null;
    beforeEach(function() {
      return creds = new AWS.WebIdentityCredentials({
        WebIdentityToken: 'token',
        RoleArn: 'arn'
      });
    });
    mockSTS = function(expireTime) {
      return spyOn(creds.service, 'assumeRoleWithWebIdentity').andCallFake(function(params, cb) {
        expect(params).toEqual({
          RoleArn: 'arn',
          WebIdentityToken: 'token',
          RoleSessionName: 'web-identity'
        });
        return cb(null, {
          Credentials: {
            AccessKeyId: 'KEY',
            SecretAccessKey: 'SECRET',
            SessionToken: 'TOKEN',
            Expiration: expireTime
          },
          OtherProperty: true
        });
      });
    };
    return describe('refresh', function() {
      it('loads federated credentials from STS', function() {
        mockSTS(new Date(AWS.util.date.getDate().getTime() + 100000));
        creds.refresh(function() {});
        expect(creds.accessKeyId).toEqual('KEY');
        expect(creds.secretAccessKey).toEqual('SECRET');
        expect(creds.sessionToken).toEqual('TOKEN');
        expect(creds.needsRefresh()).toEqual(false);
        return expect(creds.data.OtherProperty).toEqual(true);
      });
      return it('does try to load creds second time if service request failed', function() {
        var spy;
        spy = spyOn(creds.service, 'assumeRoleWithWebIdentity').andCallFake(function(params, cb) {
          return cb(new Error('INVALID SERVICE'));
        });
        creds.refresh(function(err) {
          return expect(err.message).toEqual('INVALID SERVICE');
        });
        return creds.refresh(function() {
          return creds.refresh(function() {
            return creds.refresh(function() {
              return expect(spy.calls.length).toEqual(4);
            });
          });
        });
      });
    });
  });

  describe('AWS.SAMLCredentials', function() {
    var creds, mockSTS;
    creds = null;
    beforeEach(function() {
      return creds = new AWS.SAMLCredentials({
        SAMLAssertion: 'token',
        RoleArn: 'arn',
        PrincipalArn: 'arn'
      });
    });
    mockSTS = function(expireTime) {
      return spyOn(creds.service, 'assumeRoleWithSAML').andCallFake(function(params, cb) {
        expect(params).toEqual({
          SAMLAssertion: 'token',
          RoleArn: 'arn',
          PrincipalArn: 'arn'
        });
        return cb(null, {
          Credentials: {
            AccessKeyId: 'KEY',
            SecretAccessKey: 'SECRET',
            SessionToken: 'TOKEN',
            Expiration: expireTime
          }
        });
      });
    };
    return describe('refresh', function() {
      it('loads federated credentials from STS', function() {
        mockSTS(new Date(AWS.util.date.getDate().getTime() + 100000));
        creds.refresh(function() {});
        expect(creds.accessKeyId).toEqual('KEY');
        expect(creds.secretAccessKey).toEqual('SECRET');
        expect(creds.sessionToken).toEqual('TOKEN');
        return expect(creds.needsRefresh()).toEqual(false);
      });
      return it('does try to load creds second time if service request failed', function() {
        var spy;
        spy = spyOn(creds.service, 'assumeRoleWithSAML').andCallFake(function(params, cb) {
          return cb(new Error('INVALID SERVICE'));
        });
        creds.refresh(function(err) {
          return expect(err.message).toEqual('INVALID SERVICE');
        });
        return creds.refresh(function() {
          return creds.refresh(function() {
            return creds.refresh(function() {
              return expect(spy.calls.length).toEqual(4);
            });
          });
        });
      });
    });
  });

}).call(this);
